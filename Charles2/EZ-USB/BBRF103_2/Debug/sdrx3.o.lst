   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"sdrx3.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.global	CyFxGpifTransition
  17              		.data
  18              		.align	2
  21              	CyFxGpifTransition:
  22 0000 0000     		.short	0
  23 0002 AAAA     		.short	-21846
  24 0004 5555     		.short	21845
  25 0006 FFFF     		.short	-1
  26              		.global	CyFxGpifWavedata
  27              		.align	2
  30              	CyFxGpifWavedata:
  31 0008 019A731E 		.word	510892545
  32 000c 04110020 		.word	536875268
  33 0010 80000080 		.word	-2147483520
  34 0014 00000000 		.word	0
  35 0018 00000000 		.word	0
  36 001c 00000000 		.word	0
  37 0020 0294731E 		.word	510891010
  38 0024 00090020 		.word	536873216
  39 0028 40000080 		.word	-2147483584
  40 002c 049C733E 		.word	1047763972
  41 0030 00000000 		.word	0
  42 0034 00010080 		.word	-2147483392
  43 0038 039A731E 		.word	510892547
  44 003c 04210024 		.word	603988228
  45 0040 80000080 		.word	-2147483520
  46 0044 00000000 		.word	0
  47 0048 00000000 		.word	0
  48 004c 00000000 		.word	0
  49 0050 0594731E 		.word	510891013
  50 0054 00050024 		.word	603981056
  51 0058 40000080 		.word	-2147483584
  52 005c 069C733E 		.word	1047763974
  53 0060 00000000 		.word	0
  54 0064 00010080 		.word	-2147483392
  55 0068 089A731E 		.word	510892552
  56 006c 00050000 		.word	1280
  57 0070 00000080 		.word	-2147483648
  58 0074 00000000 		.word	0
  59 0078 00000000 		.word	0
  60 007c 00000000 		.word	0
  61 0080 079A731E 		.word	510892551
  62 0084 00090004 		.word	67111168
  63 0088 00000080 		.word	-2147483648
  64 008c 00000000 		.word	0
  65 0090 00000000 		.word	0
  66 0094 00000000 		.word	0
  67              		.global	CyFxGpifWavedataPosition
  68              		.align	2
  71              	CyFxGpifWavedataPosition:
  72 0098 00       		.byte	0
  73 0099 01       		.byte	1
  74 009a 02       		.byte	2
  75 009b 03       		.byte	3
  76 009c 04       		.byte	4
  77 009d 00       		.byte	0
  78 009e 05       		.byte	5
  79 009f 02       		.byte	2
  80 00a0 00       		.byte	0
  81              		.global	CyFxGpifRegValue
  82 00a1 000000   		.align	2
  85              	CyFxGpifRegValue:
  86 00a4 00830080 		.word	-2147450112
  87 00a8 03000000 		.word	3
  88 00ac 00000000 		.word	0
  89 00b0 46000000 		.word	70
  90 00b4 00000000 		.word	0
  91 00b8 00000000 		.word	0
  92 00bc 02000000 		.word	2
  93 00c0 82000000 		.word	130
  94 00c4 82070000 		.word	1922
  95 00c8 55000000 		.word	85
  96 00cc FFFF0000 		.word	65535
  97 00d0 00000000 		.word	0
  98 00d4 00000000 		.word	0
  99 00d8 00000000 		.word	0
 100 00dc 02000000 		.word	2
 101 00e0 01000000 		.word	1
 102 00e4 03000000 		.word	3
 103 00e8 00000000 		.word	0
 104 00ec 00000000 		.word	0
 105 00f0 00000000 		.word	0
 106 00f4 00000000 		.word	0
 107 00f8 00000000 		.word	0
 108 00fc 00000000 		.word	0
 109 0100 00000000 		.word	0
 110 0104 00000000 		.word	0
 111 0108 00000000 		.word	0
 112 010c 00000000 		.word	0
 113 0110 00000000 		.word	0
 114 0114 00000000 		.word	0
 115 0118 06000000 		.word	6
 116 011c 00000000 		.word	0
 117 0120 FFFF0000 		.word	65535
 118 0124 0A010000 		.word	266
 119 0128 00000000 		.word	0
 120 012c FFFF0000 		.word	65535
 121 0130 00000000 		.word	0
 122 0134 FFFF0000 		.word	65535
 123 0138 09010000 		.word	265
 124 013c 00000000 		.word	0
 125 0140 FE070000 		.word	2046
 126 0144 00000000 		.word	0
 127 0148 00000000 		.word	0
 128 014c 00000000 		.word	0
 129 0150 00000000 		.word	0
 130 0154 00000000 		.word	0
 131 0158 00000000 		.word	0
 132 015c 00000000 		.word	0
 133 0160 00000000 		.word	0
 134 0164 00000000 		.word	0
 135 0168 00000000 		.word	0
 136 016c 00000000 		.word	0
 137 0170 00000000 		.word	0
 138 0174 00000000 		.word	0
 139 0178 00000000 		.word	0
 140 017c 00000000 		.word	0
 141 0180 00000000 		.word	0
 142 0184 00000000 		.word	0
 143 0188 00000000 		.word	0
 144 018c 00000000 		.word	0
 145 0190 00000000 		.word	0
 146 0194 00000000 		.word	0
 147 0198 00000000 		.word	0
 148 019c 00000000 		.word	0
 149 01a0 00040180 		.word	-2147417088
 150 01a4 01040180 		.word	-2147417087
 151 01a8 02040180 		.word	-2147417086
 152 01ac 03040180 		.word	-2147417085
 153 01b0 00000000 		.word	0
 154 01b4 00000000 		.word	0
 155 01b8 00000000 		.word	0
 156 01bc 00001400 		.word	1310720
 157 01c0 00000000 		.word	0
 158 01c4 00000000 		.word	0
 159 01c8 00000000 		.word	0
 160 01cc 00000000 		.word	0
 161 01d0 C1FFFFFF 		.word	-63
 162              		.global	CyFxGpifConfig
 163              		.section	.rodata
 164              		.align	2
 167              	CyFxGpifConfig:
 168 0000 0900     		.short	9
 169 0002 0000     		.space	2
 170 0004 00000000 		.word	CyFxGpifWavedata
 171 0008 00000000 		.word	CyFxGpifWavedataPosition
 172 000c 0400     		.short	4
 173 000e 0000     		.space	2
 174 0010 00000000 		.word	CyFxGpifTransition
 175 0014 4C00     		.short	76
 176 0016 0000     		.space	2
 177 0018 00000000 		.word	CyFxGpifRegValue
 178              		.comm	glEp0Buffer,32,4
 179              		.comm	glRecvdLen,2,2
 180              		.comm	SDR_AppThread,168,4
 181              		.comm	glChHandleBulkSrc,232,4
 182              		.global	glIsApplnActive
 183              		.bss
 184              		.align	2
 187              	glIsApplnActive:
 188 0000 00000000 		.space	4
 189              		.global	glStartSDRGpif
 190              		.align	2
 193              	glStartSDRGpif:
 194 0004 00000000 		.space	4
 195              		.global	glDMARxCount
 196              		.align	2
 199              	glDMARxCount:
 200 0008 00000000 		.space	4
 201              		.global	glDMATxCount
 202              		.align	2
 205              	glDMATxCount:
 206 000c 00000000 		.space	4
 207              		.global	glFirmwareID
 208              		.section	.rodata
 209 001c 00000000 		.align	5
 212              	glFirmwareID:
 213 0020 53       		.byte	83
 214 0021 44       		.byte	68
 215 0022 44       		.byte	68
 216 0023 43       		.byte	67
 217 0024 42       		.byte	66
 218 0025 30       		.byte	48
 219 0026 31       		.byte	49
 220 0027 00       		.byte	0
 221 0028 00000000 		.space	24
 221      00000000 
 221      00000000 
 221      00000000 
 221      00000000 
 222              		.text
 223              		.align	2
 224              		.global	SDR_ErrorHandler
 226              	SDR_ErrorHandler:
 227              	.LFB0:
 228              		.file 1 "../sdrx3.c"
   1:../sdrx3.c    **** /*
   2:../sdrx3.c    ****  ## Cypress USB 3.0 Platform source file (SDRx3.c)
   3:../sdrx3.c    ****  ## ===========================
   4:../sdrx3.c    ****  ##
   5:../sdrx3.c    ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2011,
   6:../sdrx3.c    ****  ##  All Rights Reserved
   7:../sdrx3.c    ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../sdrx3.c    ****  ##
   9:../sdrx3.c    ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../sdrx3.c    ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../sdrx3.c    ****  ##
  12:../sdrx3.c    ****  ##  Use of this file is governed
  13:../sdrx3.c    ****  ##  by the license agreement included in the file
  14:../sdrx3.c    ****  ##
  15:../sdrx3.c    ****  ##     <install>/license/license.txt
  16:../sdrx3.c    ****  ##
  17:../sdrx3.c    ****  ##  where <install> is the Cypress software
  18:../sdrx3.c    ****  ##  installation root directory path.
  19:../sdrx3.c    ****  ##
  20:../sdrx3.c    ****  ## ===========================
  21:../sdrx3.c    ****  */
  22:../sdrx3.c    **** 
  23:../sdrx3.c    **** /* This file illustrates the bulk source sink application example using the DMA MANUAL_IN
  24:../sdrx3.c    ****  * and DMA MANUAL_OUT mode */
  25:../sdrx3.c    **** 
  26:../sdrx3.c    **** /*
  27:../sdrx3.c    ****    This example illustrates USB endpoint data source and data sink mechanism. The example
  28:../sdrx3.c    ****    comprises of vendor class USB enumeration descriptors with 2 bulk endpoints. A bulk OUT
  29:../sdrx3.c    ****    endpoint acts as the producer of data and acts as the sink to the host. A bulk IN endpoint
  30:../sdrx3.c    ****    acts as the consumer of data and acts as the source to the host.
  31:../sdrx3.c    **** 
  32:../sdrx3.c    ****    The data source and sink is achieved with the help of a DMA MANUAL IN channel and a DMA
  33:../sdrx3.c    ****    MANUAL OUT channel. A DMA MANUAL IN channel is created between the producer USB bulk
  34:../sdrx3.c    ****    endpoint and the CPU. A DMA MANUAL OUT channel is created between the CPU and the consumer
  35:../sdrx3.c    ****    USB bulk endpoint. Data is received in the IN channel DMA buffer from the host through the
  36:../sdrx3.c    ****    producer endpoint. CPU is signalled of the data reception using DMA callbacks. The CPU
  37:../sdrx3.c    ****    discards this buffer. This leads to the sink mechanism. A constant patern data is loaded
  38:../sdrx3.c    ****    onto the OUT Channel DMA buffer whenever the buffer is available. CPU issues commit of
  39:../sdrx3.c    ****    the DMA data transfer to the consumer endpoint which then gets transferred to the host.
  40:../sdrx3.c    ****    This leads to a constant source mechanism.
  41:../sdrx3.c    **** 
  42:../sdrx3.c    ****    The DMA buffer size is defined based on the USB speed. 64 for full speed, 512 for high speed
  43:../sdrx3.c    ****    and 1024 for super speed. CY_FX_BULKSRCSINK_DMA_BUF_COUNT in the header file defines the
  44:../sdrx3.c    ****    number of DMA buffers.
  45:../sdrx3.c    **** 
  46:../sdrx3.c    ****    For performance optimizations refer the readme.txt
  47:../sdrx3.c    ****  */
  48:../sdrx3.c    **** 
  49:../sdrx3.c    **** #include "cyu3system.h"
  50:../sdrx3.c    **** #include "cyu3os.h"
  51:../sdrx3.c    **** #include "cyu3dma.h"
  52:../sdrx3.c    **** #include "cyu3error.h"
  53:../sdrx3.c    **** #include "cyu3usb.h"
  54:../sdrx3.c    **** #include "cyu3uart.h"
  55:../sdrx3.c    **** #include "cyu3gpif.h"
  56:../sdrx3.c    **** #include "cyu3gpio.h"
  57:../sdrx3.c    **** #include "cyu3pib.h"
  58:../sdrx3.c    **** #include "pib_regs.h"
  59:../sdrx3.c    **** #include "i2cmodule.h"
  60:../sdrx3.c    **** #include "cyfxgpif2config.h"
  61:../sdrx3.c    **** #include "sdrx3.h"
  62:../sdrx3.c    **** 
  63:../sdrx3.c    **** uint8_t  glEp0Buffer[32];
  64:../sdrx3.c    **** uint16_t glRecvdLen;
  65:../sdrx3.c    **** CyU3PThread     SDR_AppThread;	 /* Application thread structure */
  66:../sdrx3.c    **** // CyU3PDmaChannel glChHandleBulkSink;      /* DMA MANUAL_IN channel handle.          */
  67:../sdrx3.c    **** CyU3PDmaMultiChannel glChHandleBulkSrc;       /* DMA MANUAL_OUT channel handle.         */
  68:../sdrx3.c    **** 
  69:../sdrx3.c    **** CyBool_t glIsApplnActive = CyFalse;      /* Whether the source sink application is active or not. *
  70:../sdrx3.c    **** CyBool_t glStartSDRGpif = CyFalse;
  71:../sdrx3.c    **** uint32_t glDMARxCount = 0;               /* Counter to track the number of buffers received. */
  72:../sdrx3.c    **** uint32_t glDMATxCount = 0;               /* Counter to track the number of buffers transmitted. */
  73:../sdrx3.c    **** 
  74:../sdrx3.c    **** /* Firmware ID variable that may be used to verify I2C firmware. */
  75:../sdrx3.c    **** const uint8_t glFirmwareID[32] __attribute__ ((aligned (32))) = { 'S', 'D', 'D', 'C', 'B', '0', '1'
  76:../sdrx3.c    **** 
  77:../sdrx3.c    **** 
  78:../sdrx3.c    **** /* Application Error Handler */
  79:../sdrx3.c    **** void
  80:../sdrx3.c    **** SDR_ErrorHandler (
  81:../sdrx3.c    ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
  82:../sdrx3.c    ****         )
  83:../sdrx3.c    **** {
 229              		.loc 1 83 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 16
 232              		@ frame_needed = 1, uses_anonymous_args = 0
 233 0000 00482DE9 		stmfd	sp!, {fp, lr}
 234              	.LCFI0:
 235              		.cfi_def_cfa_offset 8
 236              		.cfi_offset 11, -8
 237              		.cfi_offset 14, -4
 238 0004 04B08DE2 		add	fp, sp, #4
 239              	.LCFI1:
 240              		.cfi_def_cfa 11, 4
 241 0008 10D04DE2 		sub	sp, sp, #16
 242 000c 10000BE5 		str	r0, [fp, #-16]
  84:../sdrx3.c    ****     /* Application failed with the error code apiRetStatus */
  85:../sdrx3.c    **** // LED_OVERLOAD GPIO21 start
  86:../sdrx3.c    **** // LED_MODEA 	GPIO22 ==> 0
  87:../sdrx3.c    **** // LED_MODEB 	GPIO23 ==> 1
  88:../sdrx3.c    **** 	uint8_t i,x,y;
  89:../sdrx3.c    **** 
  90:../sdrx3.c    ****     /* Loop Indefinitely */
  91:../sdrx3.c    **** 	x = (uint8_t) apiRetStatus;
 243              		.loc 1 91 0
 244 0010 10301BE5 		ldr	r3, [fp, #-16]
 245 0014 07304BE5 		strb	r3, [fp, #-7]
 246              	.L6:
  92:../sdrx3.c    ****     for (;;)
  93:../sdrx3.c    ****     {
  94:../sdrx3.c    ****     	y = x;
 247              		.loc 1 94 0
 248 0018 07305BE5 		ldrb	r3, [fp, #-7]
 249 001c 06304BE5 		strb	r3, [fp, #-6]
  95:../sdrx3.c    ****     	CyU3PGpioSetValue (LED_OVERLOAD, 1);
 250              		.loc 1 95 0
 251 0020 1500A0E3 		mov	r0, #21
 252 0024 0110A0E3 		mov	r1, #1
 253 0028 FEFFFFEB 		bl	CyU3PGpioSetValue
  96:../sdrx3.c    ****         CyU3PThreadSleep (300);   /* Thread sleep : 200 ms */
 254              		.loc 1 96 0
 255 002c 4B0FA0E3 		mov	r0, #300
 256 0030 FEFFFFEB 		bl	_tx_thread_sleep
  97:../sdrx3.c    ****     	CyU3PGpioSetValue (LED_OVERLOAD, 0);
 257              		.loc 1 97 0
 258 0034 1500A0E3 		mov	r0, #21
 259 0038 0010A0E3 		mov	r1, #0
 260 003c FEFFFFEB 		bl	CyU3PGpioSetValue
  98:../sdrx3.c    ****     	CyU3PThreadSleep (200);   /* Thread sleep : 100 ms */
 261              		.loc 1 98 0
 262 0040 C800A0E3 		mov	r0, #200
 263 0044 FEFFFFEB 		bl	_tx_thread_sleep
  99:../sdrx3.c    ****         for (i =0; i < 8 ;i++)
 264              		.loc 1 99 0
 265 0048 0030A0E3 		mov	r3, #0
 266 004c 05304BE5 		strb	r3, [fp, #-5]
 267 0050 210000EA 		b	.L2
 268              	.L5:
 100:../sdrx3.c    ****         {
 101:../sdrx3.c    ****         	if ((y & 0x80) == 0)
 269              		.loc 1 101 0
 270 0054 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 271 0058 033CA0E1 		mov	r3, r3, asl #24
 272 005c 433CA0E1 		mov	r3, r3, asr #24
 273 0060 000053E3 		cmp	r3, #0
 274 0064 060000BA 		blt	.L3
 102:../sdrx3.c    ****         	{
 103:../sdrx3.c    ****         		CyU3PGpioSetValue (LED_MODEA, 1);
 275              		.loc 1 103 0
 276 0068 1600A0E3 		mov	r0, #22
 277 006c 0110A0E3 		mov	r1, #1
 278 0070 FEFFFFEB 		bl	CyU3PGpioSetValue
 104:../sdrx3.c    ****         		CyU3PGpioSetValue (LED_MODEB, 0);
 279              		.loc 1 104 0
 280 0074 1700A0E3 		mov	r0, #23
 281 0078 0010A0E3 		mov	r1, #0
 282 007c FEFFFFEB 		bl	CyU3PGpioSetValue
 283 0080 050000EA 		b	.L4
 284              	.L3:
 105:../sdrx3.c    ****         	}
 106:../sdrx3.c    ****         	else
 107:../sdrx3.c    ****         	{
 108:../sdrx3.c    ****         		CyU3PGpioSetValue (LED_MODEA, 0);
 285              		.loc 1 108 0
 286 0084 1600A0E3 		mov	r0, #22
 287 0088 0010A0E3 		mov	r1, #0
 288 008c FEFFFFEB 		bl	CyU3PGpioSetValue
 109:../sdrx3.c    ****         		CyU3PGpioSetValue (LED_MODEB, 1);
 289              		.loc 1 109 0
 290 0090 1700A0E3 		mov	r0, #23
 291 0094 0110A0E3 		mov	r1, #1
 292 0098 FEFFFFEB 		bl	CyU3PGpioSetValue
 293              	.L4:
 110:../sdrx3.c    ****         	}
 111:../sdrx3.c    ****         	CyU3PThreadSleep (500);   /* Thread sleep : 200 ms */
 294              		.loc 1 111 0
 295 009c 7D0FA0E3 		mov	r0, #500
 296 00a0 FEFFFFEB 		bl	_tx_thread_sleep
 112:../sdrx3.c    ****     		CyU3PGpioSetValue (LED_MODEA, 0);
 297              		.loc 1 112 0
 298 00a4 1600A0E3 		mov	r0, #22
 299 00a8 0010A0E3 		mov	r1, #0
 300 00ac FEFFFFEB 		bl	CyU3PGpioSetValue
 113:../sdrx3.c    ****     		CyU3PGpioSetValue (LED_MODEB, 0);
 301              		.loc 1 113 0
 302 00b0 1700A0E3 		mov	r0, #23
 303 00b4 0010A0E3 		mov	r1, #0
 304 00b8 FEFFFFEB 		bl	CyU3PGpioSetValue
 114:../sdrx3.c    ****         	CyU3PThreadSleep (200);   /* Thread sleep : 100 ms */
 305              		.loc 1 114 0
 306 00bc C800A0E3 		mov	r0, #200
 307 00c0 FEFFFFEB 		bl	_tx_thread_sleep
 115:../sdrx3.c    ****         	y = y << 1 ;
 308              		.loc 1 115 0
 309 00c4 06305BE5 		ldrb	r3, [fp, #-6]
 310 00c8 8330A0E1 		mov	r3, r3, asl #1
 311 00cc 06304BE5 		strb	r3, [fp, #-6]
  99:../sdrx3.c    ****         {
 312              		.loc 1 99 0
 313 00d0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 314 00d4 013083E2 		add	r3, r3, #1
 315 00d8 05304BE5 		strb	r3, [fp, #-5]
 316              	.L2:
  99:../sdrx3.c    ****         {
 317              		.loc 1 99 0 is_stmt 0 discriminator 1
 318 00dc 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 319 00e0 070053E3 		cmp	r3, #7
 320 00e4 DAFFFF9A 		bls	.L5
 116:../sdrx3.c    ****         }
 117:../sdrx3.c    ****     }
 321              		.loc 1 117 0 is_stmt 1
 322 00e8 CAFFFFEA 		b	.L6
 323              		.cfi_endproc
 324              	.LFE0:
 326              		.align	2
 327              		.global	SDR_GpioIntrCb
 329              	SDR_GpioIntrCb:
 330              	.LFB1:
 118:../sdrx3.c    **** }
 119:../sdrx3.c    **** 
 120:../sdrx3.c    **** 
 121:../sdrx3.c    **** 
 122:../sdrx3.c    **** 
 123:../sdrx3.c    **** /* GPIO interrupt callback handler. This is received from
 124:../sdrx3.c    ****  * the interrupt context. So DebugPrint API is not available
 125:../sdrx3.c    ****  * from here. Set an event in the event group so that the
 126:../sdrx3.c    ****  * GPIO thread can print the event information. */
 127:../sdrx3.c    **** void SDR_GpioIntrCb (
 128:../sdrx3.c    ****         uint8_t gpioId /* Indicates the pin that triggered the interrupt */
 129:../sdrx3.c    ****         )
 130:../sdrx3.c    **** {
 331              		.loc 1 130 0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 16
 334              		@ frame_needed = 1, uses_anonymous_args = 0
 335 00ec 00482DE9 		stmfd	sp!, {fp, lr}
 336              	.LCFI2:
 337              		.cfi_def_cfa_offset 8
 338              		.cfi_offset 11, -8
 339              		.cfi_offset 14, -4
 340 00f0 04B08DE2 		add	fp, sp, #4
 341              	.LCFI3:
 342              		.cfi_def_cfa 11, 4
 343 00f4 10D04DE2 		sub	sp, sp, #16
 344 00f8 0030A0E1 		mov	r3, r0
 345 00fc 0D304BE5 		strb	r3, [fp, #-13]
 131:../sdrx3.c    ****     CyBool_t gpioValue = CyFalse;
 346              		.loc 1 131 0
 347 0100 0030A0E3 		mov	r3, #0
 348 0104 0C300BE5 		str	r3, [fp, #-12]
 132:../sdrx3.c    ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 349              		.loc 1 132 0
 350 0108 0030A0E3 		mov	r3, #0
 351 010c 08300BE5 		str	r3, [fp, #-8]
 133:../sdrx3.c    **** 
 134:../sdrx3.c    ****     /* Get the status of the pin */
 135:../sdrx3.c    ****     apiRetStatus = CyU3PGpioGetValue (gpioId, &gpioValue);
 352              		.loc 1 135 0
 353 0110 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 354 0114 0C304BE2 		sub	r3, fp, #12
 355 0118 0200A0E1 		mov	r0, r2
 356 011c 0310A0E1 		mov	r1, r3
 357 0120 FEFFFFEB 		bl	CyU3PGpioGetValue
 358 0124 08000BE5 		str	r0, [fp, #-8]
 136:../sdrx3.c    ****     if (apiRetStatus == CY_U3P_SUCCESS)
 359              		.loc 1 136 0
 360 0128 08301BE5 		ldr	r3, [fp, #-8]
 361 012c 000053E3 		cmp	r3, #0
 137:../sdrx3.c    ****     {
 138:../sdrx3.c    ****         /* Check status of the pin */
 139:../sdrx3.c    ****         if (gpioValue == CyTrue)
 140:../sdrx3.c    ****         {
 141:../sdrx3.c    ****             /* Set GPIO high event */
 142:../sdrx3.c    ****         }
 143:../sdrx3.c    ****         else
 144:../sdrx3.c    ****         {
 145:../sdrx3.c    ****             /* Set GPIO low Event */
 146:../sdrx3.c    ****         }
 147:../sdrx3.c    ****     }
 148:../sdrx3.c    **** }
 362              		.loc 1 148 0
 363 0130 04D04BE2 		sub	sp, fp, #4
 364              		@ sp needed
 365 0134 0088BDE8 		ldmfd	sp!, {fp, pc}
 366              		.cfi_endproc
 367              	.LFE1:
 369              		.align	2
 370              		.global	ConfGPIOsimpleout
 372              	ConfGPIOsimpleout:
 373              	.LFB2:
 149:../sdrx3.c    **** CyU3PReturnStatus_t
 150:../sdrx3.c    **** ConfGPIOsimpleout( uint8_t gpioid)
 151:../sdrx3.c    **** {
 374              		.loc 1 151 0
 375              		.cfi_startproc
 376              		@ args = 0, pretend = 0, frame = 32
 377              		@ frame_needed = 1, uses_anonymous_args = 0
 378 0138 00482DE9 		stmfd	sp!, {fp, lr}
 379              	.LCFI4:
 380              		.cfi_def_cfa_offset 8
 381              		.cfi_offset 11, -8
 382              		.cfi_offset 14, -4
 383 013c 04B08DE2 		add	fp, sp, #4
 384              	.LCFI5:
 385              		.cfi_def_cfa 11, 4
 386 0140 20D04DE2 		sub	sp, sp, #32
 387 0144 0030A0E1 		mov	r3, r0
 388 0148 1D304BE5 		strb	r3, [fp, #-29]
 152:../sdrx3.c    **** 	 CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 389              		.loc 1 152 0
 390 014c 0030A0E3 		mov	r3, #0
 391 0150 08300BE5 		str	r3, [fp, #-8]
 153:../sdrx3.c    **** 	 CyU3PGpioSimpleConfig_t gpioConfig;
 154:../sdrx3.c    **** 
 155:../sdrx3.c    **** 	  apiRetStatus = CyU3PDeviceGpioOverride (gpioid, CyTrue);
 392              		.loc 1 155 0
 393 0154 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 394 0158 0300A0E1 		mov	r0, r3
 395 015c 0110A0E3 		mov	r1, #1
 396 0160 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 397 0164 08000BE5 		str	r0, [fp, #-8]
 156:../sdrx3.c    **** 	    if (apiRetStatus != 0)
 398              		.loc 1 156 0
 399 0168 08301BE5 		ldr	r3, [fp, #-8]
 400 016c 000053E3 		cmp	r3, #0
 401 0170 0100000A 		beq	.L10
 157:../sdrx3.c    **** 	    {
 158:../sdrx3.c    **** 	        /* Error Handling */
 159:../sdrx3.c    **** 	        SDR_ErrorHandler (apiRetStatus);
 402              		.loc 1 159 0
 403 0174 08001BE5 		ldr	r0, [fp, #-8]
 404 0178 FEFFFFEB 		bl	SDR_ErrorHandler
 405              	.L10:
 160:../sdrx3.c    **** 	    }
 161:../sdrx3.c    **** 	    /* Configure GPIO gpioid as output */
 162:../sdrx3.c    **** 	      gpioConfig.outValue = CyFalse;
 406              		.loc 1 162 0
 407 017c 0030A0E3 		mov	r3, #0
 408 0180 1C300BE5 		str	r3, [fp, #-28]
 163:../sdrx3.c    **** 	      gpioConfig.driveLowEn = CyTrue;
 409              		.loc 1 163 0
 410 0184 0130A0E3 		mov	r3, #1
 411 0188 18300BE5 		str	r3, [fp, #-24]
 164:../sdrx3.c    **** 	      gpioConfig.driveHighEn = CyTrue;
 412              		.loc 1 164 0
 413 018c 0130A0E3 		mov	r3, #1
 414 0190 14300BE5 		str	r3, [fp, #-20]
 165:../sdrx3.c    **** 	      gpioConfig.inputEn = CyFalse;
 415              		.loc 1 165 0
 416 0194 0030A0E3 		mov	r3, #0
 417 0198 10300BE5 		str	r3, [fp, #-16]
 166:../sdrx3.c    **** 	      gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
 418              		.loc 1 166 0
 419 019c 0030A0E3 		mov	r3, #0
 420 01a0 0C304BE5 		strb	r3, [fp, #-12]
 167:../sdrx3.c    **** 	      apiRetStatus = CyU3PGpioSetSimpleConfig(gpioid , &gpioConfig);
 421              		.loc 1 167 0
 422 01a4 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 423 01a8 1C304BE2 		sub	r3, fp, #28
 424 01ac 0200A0E1 		mov	r0, r2
 425 01b0 0310A0E1 		mov	r1, r3
 426 01b4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 427 01b8 08000BE5 		str	r0, [fp, #-8]
 168:../sdrx3.c    **** 	      if (apiRetStatus != CY_U3P_SUCCESS)
 428              		.loc 1 168 0
 429 01bc 08301BE5 		ldr	r3, [fp, #-8]
 430 01c0 000053E3 		cmp	r3, #0
 431 01c4 0100000A 		beq	.L11
 169:../sdrx3.c    **** 	      {
 170:../sdrx3.c    **** 	          /* Error handling */
 171:../sdrx3.c    **** 	          SDR_ErrorHandler (apiRetStatus);
 432              		.loc 1 171 0
 433 01c8 08001BE5 		ldr	r0, [fp, #-8]
 434 01cc FEFFFFEB 		bl	SDR_ErrorHandler
 435              	.L11:
 172:../sdrx3.c    **** 	      }
 173:../sdrx3.c    **** 	 return apiRetStatus;
 436              		.loc 1 173 0
 437 01d0 08301BE5 		ldr	r3, [fp, #-8]
 174:../sdrx3.c    **** }
 438              		.loc 1 174 0
 439 01d4 0300A0E1 		mov	r0, r3
 440 01d8 04D04BE2 		sub	sp, fp, #4
 441              		@ sp needed
 442 01dc 0088BDE8 		ldmfd	sp!, {fp, pc}
 443              		.cfi_endproc
 444              	.LFE2:
 446              		.align	2
 447              		.global	ConfGPIOPWM
 449              	ConfGPIOPWM:
 450              	.LFB3:
 175:../sdrx3.c    **** 
 176:../sdrx3.c    **** CyU3PReturnStatus_t
 177:../sdrx3.c    **** ConfGPIOPWM (uint8_t gpioid ,uint32_t value)
 178:../sdrx3.c    **** {
 451              		.loc 1 178 0
 452              		.cfi_startproc
 453              		@ args = 0, pretend = 0, frame = 48
 454              		@ frame_needed = 1, uses_anonymous_args = 0
 455 01e0 00482DE9 		stmfd	sp!, {fp, lr}
 456              	.LCFI6:
 457              		.cfi_def_cfa_offset 8
 458              		.cfi_offset 11, -8
 459              		.cfi_offset 14, -4
 460 01e4 04B08DE2 		add	fp, sp, #4
 461              	.LCFI7:
 462              		.cfi_def_cfa 11, 4
 463 01e8 30D04DE2 		sub	sp, sp, #48
 464 01ec 0030A0E1 		mov	r3, r0
 465 01f0 34100BE5 		str	r1, [fp, #-52]
 466 01f4 2D304BE5 		strb	r3, [fp, #-45]
 179:../sdrx3.c    **** 	  CyU3PGpioComplexConfig_t gpioConfig;
 180:../sdrx3.c    **** 	    CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 467              		.loc 1 180 0
 468 01f8 0030A0E3 		mov	r3, #0
 469 01fc 08300BE5 		str	r3, [fp, #-8]
 181:../sdrx3.c    **** 	    apiRetStatus = CyU3PDeviceGpioOverride ( gpioid, CyTrue);
 470              		.loc 1 181 0
 471 0200 2D305BE5 		ldrb	r3, [fp, #-45]	@ zero_extendqisi2
 472 0204 0300A0E1 		mov	r0, r3
 473 0208 0110A0E3 		mov	r1, #1
 474 020c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 475 0210 08000BE5 		str	r0, [fp, #-8]
 182:../sdrx3.c    **** 	   	    if (apiRetStatus != 0)
 476              		.loc 1 182 0
 477 0214 08301BE5 		ldr	r3, [fp, #-8]
 478 0218 000053E3 		cmp	r3, #0
 479 021c 0100000A 		beq	.L14
 183:../sdrx3.c    **** 	   	    {
 184:../sdrx3.c    **** 	   	        // Error Handling
 185:../sdrx3.c    **** 	   	        SDR_ErrorHandler (apiRetStatus);
 480              		.loc 1 185 0
 481 0220 08001BE5 		ldr	r0, [fp, #-8]
 482 0224 FEFFFFEB 		bl	SDR_ErrorHandler
 483              	.L14:
 186:../sdrx3.c    **** 	   	    }
 187:../sdrx3.c    ****     // Configure GPIO  as PWM output
 188:../sdrx3.c    ****     gpioConfig.outValue = CyFalse;
 484              		.loc 1 188 0
 485 0228 0030A0E3 		mov	r3, #0
 486 022c 28300BE5 		str	r3, [fp, #-40]
 189:../sdrx3.c    ****     gpioConfig.inputEn = CyFalse;
 487              		.loc 1 189 0
 488 0230 0030A0E3 		mov	r3, #0
 489 0234 1C300BE5 		str	r3, [fp, #-28]
 190:../sdrx3.c    ****     gpioConfig.driveLowEn = CyTrue;
 490              		.loc 1 190 0
 491 0238 0130A0E3 		mov	r3, #1
 492 023c 24300BE5 		str	r3, [fp, #-36]
 191:../sdrx3.c    ****     gpioConfig.driveHighEn = CyTrue;
 493              		.loc 1 191 0
 494 0240 0130A0E3 		mov	r3, #1
 495 0244 20300BE5 		str	r3, [fp, #-32]
 192:../sdrx3.c    ****     gpioConfig.pinMode = CY_U3P_GPIO_MODE_PWM;
 496              		.loc 1 192 0
 497 0248 0530A0E3 		mov	r3, #5
 498 024c 18304BE5 		strb	r3, [fp, #-24]
 193:../sdrx3.c    ****     gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
 499              		.loc 1 193 0
 500 0250 0030A0E3 		mov	r3, #0
 501 0254 17304BE5 		strb	r3, [fp, #-23]
 194:../sdrx3.c    ****     gpioConfig.timerMode = CY_U3P_GPIO_TIMER_HIGH_FREQ;
 502              		.loc 1 194 0
 503 0258 0130A0E3 		mov	r3, #1
 504 025c 16304BE5 		strb	r3, [fp, #-22]
 195:../sdrx3.c    ****     gpioConfig.timer = 0;
 505              		.loc 1 195 0
 506 0260 0030A0E3 		mov	r3, #0
 507 0264 14300BE5 		str	r3, [fp, #-20]
 196:../sdrx3.c    ****     gpioConfig.period = CY_FX_PWM_PERIOD;
 508              		.loc 1 196 0
 509 0268 30309FE5 		ldr	r3, .L16
 510 026c 10300BE5 		str	r3, [fp, #-16]
 197:../sdrx3.c    ****     gpioConfig.threshold = value;
 511              		.loc 1 197 0
 512 0270 34301BE5 		ldr	r3, [fp, #-52]
 513 0274 0C300BE5 		str	r3, [fp, #-12]
 198:../sdrx3.c    ****     apiRetStatus = CyU3PGpioSetComplexConfig(gpioid, &gpioConfig);
 514              		.loc 1 198 0
 515 0278 2D205BE5 		ldrb	r2, [fp, #-45]	@ zero_extendqisi2
 516 027c 28304BE2 		sub	r3, fp, #40
 517 0280 0200A0E1 		mov	r0, r2
 518 0284 0310A0E1 		mov	r1, r3
 519 0288 FEFFFFEB 		bl	CyU3PGpioSetComplexConfig
 520 028c 08000BE5 		str	r0, [fp, #-8]
 199:../sdrx3.c    ****     return  apiRetStatus;
 521              		.loc 1 199 0
 522 0290 08301BE5 		ldr	r3, [fp, #-8]
 200:../sdrx3.c    **** }
 523              		.loc 1 200 0
 524 0294 0300A0E1 		mov	r0, r3
 525 0298 04D04BE2 		sub	sp, fp, #4
 526              		@ sp needed
 527 029c 0088BDE8 		ldmfd	sp!, {fp, pc}
 528              	.L17:
 529              		.align	2
 530              	.L16:
 531 02a0 7F130300 		.word	201599
 532              		.cfi_endproc
 533              	.LFE3:
 535              		.section	.rodata
 536              		.align	2
 537              	.LC0:
 538 0040 43795533 		.ascii	"CyU3PGpioInit failed, error code = %d\012\000"
 538      50477069 
 538      6F496E69 
 538      74206661 
 538      696C6564 
 539              		.text
 540              		.align	2
 541              		.global	SDR_GpioInit
 543              	SDR_GpioInit:
 544              	.LFB4:
 201:../sdrx3.c    **** 
 202:../sdrx3.c    **** /* Init GPIOs  */
 203:../sdrx3.c    **** void
 204:../sdrx3.c    **** SDR_GpioInit (void)
 205:../sdrx3.c    **** {
 545              		.loc 1 205 0
 546              		.cfi_startproc
 547              		@ args = 0, pretend = 0, frame = 16
 548              		@ frame_needed = 1, uses_anonymous_args = 0
 549 02a4 00482DE9 		stmfd	sp!, {fp, lr}
 550              	.LCFI8:
 551              		.cfi_def_cfa_offset 8
 552              		.cfi_offset 11, -8
 553              		.cfi_offset 14, -4
 554 02a8 04B08DE2 		add	fp, sp, #4
 555              	.LCFI9:
 556              		.cfi_def_cfa 11, 4
 557 02ac 10D04DE2 		sub	sp, sp, #16
 206:../sdrx3.c    ****     CyU3PGpioClock_t gpioClock;
 207:../sdrx3.c    ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 558              		.loc 1 207 0
 559 02b0 0030A0E3 		mov	r3, #0
 560 02b4 08300BE5 		str	r3, [fp, #-8]
 208:../sdrx3.c    **** 
 209:../sdrx3.c    ****     /* Init the GPIO module */
 210:../sdrx3.c    ****     gpioClock.fastClkDiv = 2;
 561              		.loc 1 210 0
 562 02b8 0230A0E3 		mov	r3, #2
 563 02bc 14304BE5 		strb	r3, [fp, #-20]
 211:../sdrx3.c    ****     gpioClock.slowClkDiv = 0;
 564              		.loc 1 211 0
 565 02c0 0030A0E3 		mov	r3, #0
 566 02c4 13304BE5 		strb	r3, [fp, #-19]
 212:../sdrx3.c    ****     gpioClock.simpleDiv = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 567              		.loc 1 212 0
 568 02c8 0030A0E3 		mov	r3, #0
 569 02cc 0C304BE5 		strb	r3, [fp, #-12]
 213:../sdrx3.c    ****     gpioClock.clkSrc = CY_U3P_SYS_CLK;
 570              		.loc 1 213 0
 571 02d0 0330A0E3 		mov	r3, #3
 572 02d4 0B304BE5 		strb	r3, [fp, #-11]
 214:../sdrx3.c    ****     gpioClock.halfDiv = 0;
 573              		.loc 1 214 0
 574 02d8 0030A0E3 		mov	r3, #0
 575 02dc 10300BE5 		str	r3, [fp, #-16]
 215:../sdrx3.c    **** 
 216:../sdrx3.c    ****     apiRetStatus = CyU3PGpioInit(&gpioClock, SDR_GpioIntrCb);
 576              		.loc 1 216 0
 577 02e0 14304BE2 		sub	r3, fp, #20
 578 02e4 0300A0E1 		mov	r0, r3
 579 02e8 98109FE5 		ldr	r1, .L20
 580 02ec FEFFFFEB 		bl	CyU3PGpioInit
 581 02f0 08000BE5 		str	r0, [fp, #-8]
 217:../sdrx3.c    ****     if (apiRetStatus != 0)
 582              		.loc 1 217 0
 583 02f4 08301BE5 		ldr	r3, [fp, #-8]
 584 02f8 000053E3 		cmp	r3, #0
 585 02fc 0500000A 		beq	.L19
 218:../sdrx3.c    ****     {
 219:../sdrx3.c    ****         /* Error Handling */
 220:../sdrx3.c    ****         CyU3PDebugPrint (4, "CyU3PGpioInit failed, error code = %d\n", apiRetStatus);
 586              		.loc 1 220 0
 587 0300 0400A0E3 		mov	r0, #4
 588 0304 80109FE5 		ldr	r1, .L20+4
 589 0308 08201BE5 		ldr	r2, [fp, #-8]
 590 030c FEFFFFEB 		bl	CyU3PDebugPrint
 221:../sdrx3.c    ****         SDR_ErrorHandler (apiRetStatus);
 591              		.loc 1 221 0
 592 0310 08001BE5 		ldr	r0, [fp, #-8]
 593 0314 FEFFFFEB 		bl	SDR_ErrorHandler
 594              	.L19:
 222:../sdrx3.c    ****     }
 223:../sdrx3.c    **** 
 224:../sdrx3.c    ****     // Configure GPIO  as PWM output
 225:../sdrx3.c    ****     ConfGPIOPWM(24,CY_FX_PWM_25P_THRESHOLD);
 595              		.loc 1 225 0
 596 0318 1800A0E3 		mov	r0, #24
 597 031c 6C109FE5 		ldr	r1, .L20+8
 598 0320 FEFFFFEB 		bl	ConfGPIOPWM
 226:../sdrx3.c    ****     ConfGPIOsimpleout(21);
 599              		.loc 1 226 0
 600 0324 1500A0E3 		mov	r0, #21
 601 0328 FEFFFFEB 		bl	ConfGPIOsimpleout
 227:../sdrx3.c    ****     ConfGPIOsimpleout(22);
 602              		.loc 1 227 0
 603 032c 1600A0E3 		mov	r0, #22
 604 0330 FEFFFFEB 		bl	ConfGPIOsimpleout
 228:../sdrx3.c    ****     ConfGPIOsimpleout(23);
 605              		.loc 1 228 0
 606 0334 1700A0E3 		mov	r0, #23
 607 0338 FEFFFFEB 		bl	ConfGPIOsimpleout
 229:../sdrx3.c    ****     ConfGPIOsimpleout(26);
 608              		.loc 1 229 0
 609 033c 1A00A0E3 		mov	r0, #26
 610 0340 FEFFFFEB 		bl	ConfGPIOsimpleout
 230:../sdrx3.c    ****     ConfGPIOsimpleout(27);
 611              		.loc 1 230 0
 612 0344 1B00A0E3 		mov	r0, #27
 613 0348 FEFFFFEB 		bl	ConfGPIOsimpleout
 231:../sdrx3.c    ****     ConfGPIOsimpleout(28);
 614              		.loc 1 231 0
 615 034c 1C00A0E3 		mov	r0, #28
 616 0350 FEFFFFEB 		bl	ConfGPIOsimpleout
 232:../sdrx3.c    ****     ConfGPIOsimpleout(29);
 617              		.loc 1 232 0
 618 0354 1D00A0E3 		mov	r0, #29
 619 0358 FEFFFFEB 		bl	ConfGPIOsimpleout
 233:../sdrx3.c    **** 
 234:../sdrx3.c    ****     CyU3PGpioSetValue (21, 0);
 620              		.loc 1 234 0
 621 035c 1500A0E3 		mov	r0, #21
 622 0360 0010A0E3 		mov	r1, #0
 623 0364 FEFFFFEB 		bl	CyU3PGpioSetValue
 235:../sdrx3.c    ****     CyU3PGpioSetValue (22, 1);
 624              		.loc 1 235 0
 625 0368 1600A0E3 		mov	r0, #22
 626 036c 0110A0E3 		mov	r1, #1
 627 0370 FEFFFFEB 		bl	CyU3PGpioSetValue
 236:../sdrx3.c    ****     CyU3PGpioSetValue (28, 1);
 628              		.loc 1 236 0
 629 0374 1C00A0E3 		mov	r0, #28
 630 0378 0110A0E3 		mov	r1, #1
 631 037c FEFFFFEB 		bl	CyU3PGpioSetValue
 237:../sdrx3.c    **** }
 632              		.loc 1 237 0
 633 0380 04D04BE2 		sub	sp, fp, #4
 634              		@ sp needed
 635 0384 0088BDE8 		ldmfd	sp!, {fp, pc}
 636              	.L21:
 637              		.align	2
 638              	.L20:
 639 0388 00000000 		.word	SDR_GpioIntrCb
 640 038c 40000000 		.word	.LC0
 641 0390 DFC40000 		.word	50399
 642              		.cfi_endproc
 643              	.LFE4:
 645              		.align	2
 646              		.global	SDR_ApplnDebugInit
 648              	SDR_ApplnDebugInit:
 649              	.LFB5:
 238:../sdrx3.c    **** 
 239:../sdrx3.c    **** 
 240:../sdrx3.c    **** /* This function initializes the debug module. The debug prints
 241:../sdrx3.c    ****  * are routed to the UART and can be seen using a UART console
 242:../sdrx3.c    ****  * running at 115200 baud rate. */
 243:../sdrx3.c    **** void
 244:../sdrx3.c    **** SDR_ApplnDebugInit (void)
 245:../sdrx3.c    **** {
 650              		.loc 1 245 0
 651              		.cfi_startproc
 652              		@ args = 0, pretend = 0, frame = 32
 653              		@ frame_needed = 1, uses_anonymous_args = 0
 654 0394 00482DE9 		stmfd	sp!, {fp, lr}
 655              	.LCFI10:
 656              		.cfi_def_cfa_offset 8
 657              		.cfi_offset 11, -8
 658              		.cfi_offset 14, -4
 659 0398 04B08DE2 		add	fp, sp, #4
 660              	.LCFI11:
 661              		.cfi_def_cfa 11, 4
 662 039c 20D04DE2 		sub	sp, sp, #32
 246:../sdrx3.c    ****     CyU3PUartConfig_t uartConfig;
 247:../sdrx3.c    ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 663              		.loc 1 247 0
 664 03a0 0030A0E3 		mov	r3, #0
 665 03a4 08300BE5 		str	r3, [fp, #-8]
 248:../sdrx3.c    **** 
 249:../sdrx3.c    ****     /* Initialize the UART for printing debug messages */
 250:../sdrx3.c    ****     apiRetStatus = CyU3PUartInit();
 666              		.loc 1 250 0
 667 03a8 FEFFFFEB 		bl	CyU3PUartInit
 668 03ac 08000BE5 		str	r0, [fp, #-8]
 251:../sdrx3.c    ****     if (apiRetStatus != CY_U3P_SUCCESS)
 669              		.loc 1 251 0
 670 03b0 08301BE5 		ldr	r3, [fp, #-8]
 671 03b4 000053E3 		cmp	r3, #0
 672 03b8 0100000A 		beq	.L23
 252:../sdrx3.c    ****     {
 253:../sdrx3.c    ****         /* Error handling */
 254:../sdrx3.c    ****         SDR_ErrorHandler(apiRetStatus);
 673              		.loc 1 254 0
 674 03bc 08001BE5 		ldr	r0, [fp, #-8]
 675 03c0 FEFFFFEB 		bl	SDR_ErrorHandler
 676              	.L23:
 255:../sdrx3.c    ****     }
 256:../sdrx3.c    **** 
 257:../sdrx3.c    ****     /* Set UART configuration */
 258:../sdrx3.c    ****     CyU3PMemSet ((uint8_t *)&uartConfig, 0, sizeof (uartConfig));
 677              		.loc 1 258 0
 678 03c4 20304BE2 		sub	r3, fp, #32
 679 03c8 0300A0E1 		mov	r0, r3
 680 03cc 0010A0E3 		mov	r1, #0
 681 03d0 1820A0E3 		mov	r2, #24
 682 03d4 FEFFFFEB 		bl	CyU3PMemSet
 259:../sdrx3.c    ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 683              		.loc 1 259 0
 684 03d8 AC309FE5 		ldr	r3, .L27
 685 03dc 10300BE5 		str	r3, [fp, #-16]
 260:../sdrx3.c    ****     uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
 686              		.loc 1 260 0
 687 03e0 0130A0E3 		mov	r3, #1
 688 03e4 0C304BE5 		strb	r3, [fp, #-12]
 261:../sdrx3.c    ****     uartConfig.parity = CY_U3P_UART_NO_PARITY;
 689              		.loc 1 261 0
 690 03e8 0030A0E3 		mov	r3, #0
 691 03ec 0B304BE5 		strb	r3, [fp, #-11]
 262:../sdrx3.c    ****     uartConfig.txEnable = CyTrue;
 692              		.loc 1 262 0
 693 03f0 0130A0E3 		mov	r3, #1
 694 03f4 20300BE5 		str	r3, [fp, #-32]
 263:../sdrx3.c    ****     uartConfig.rxEnable = CyFalse;
 695              		.loc 1 263 0
 696 03f8 0030A0E3 		mov	r3, #0
 697 03fc 1C300BE5 		str	r3, [fp, #-28]
 264:../sdrx3.c    ****     uartConfig.flowCtrl = CyFalse;
 698              		.loc 1 264 0
 699 0400 0030A0E3 		mov	r3, #0
 700 0404 18300BE5 		str	r3, [fp, #-24]
 265:../sdrx3.c    ****     uartConfig.isDma = CyTrue;
 701              		.loc 1 265 0
 702 0408 0130A0E3 		mov	r3, #1
 703 040c 14300BE5 		str	r3, [fp, #-20]
 266:../sdrx3.c    **** 
 267:../sdrx3.c    ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 704              		.loc 1 267 0
 705 0410 20304BE2 		sub	r3, fp, #32
 706 0414 0300A0E1 		mov	r0, r3
 707 0418 0010A0E3 		mov	r1, #0
 708 041c FEFFFFEB 		bl	CyU3PUartSetConfig
 709 0420 08000BE5 		str	r0, [fp, #-8]
 268:../sdrx3.c    ****     if (apiRetStatus != CY_U3P_SUCCESS)
 710              		.loc 1 268 0
 711 0424 08301BE5 		ldr	r3, [fp, #-8]
 712 0428 000053E3 		cmp	r3, #0
 713 042c 0100000A 		beq	.L24
 269:../sdrx3.c    ****     {
 270:../sdrx3.c    ****         SDR_ErrorHandler(apiRetStatus);
 714              		.loc 1 270 0
 715 0430 08001BE5 		ldr	r0, [fp, #-8]
 716 0434 FEFFFFEB 		bl	SDR_ErrorHandler
 717              	.L24:
 271:../sdrx3.c    ****     }
 272:../sdrx3.c    **** 
 273:../sdrx3.c    ****     /* Set the UART transfer to a really large value. */
 274:../sdrx3.c    ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 718              		.loc 1 274 0
 719 0438 0000E0E3 		mvn	r0, #0
 720 043c FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 721 0440 08000BE5 		str	r0, [fp, #-8]
 275:../sdrx3.c    ****     if (apiRetStatus != CY_U3P_SUCCESS)
 722              		.loc 1 275 0
 723 0444 08301BE5 		ldr	r3, [fp, #-8]
 724 0448 000053E3 		cmp	r3, #0
 725 044c 0100000A 		beq	.L25
 276:../sdrx3.c    ****     {
 277:../sdrx3.c    ****         SDR_ErrorHandler(apiRetStatus);
 726              		.loc 1 277 0
 727 0450 08001BE5 		ldr	r0, [fp, #-8]
 728 0454 FEFFFFEB 		bl	SDR_ErrorHandler
 729              	.L25:
 278:../sdrx3.c    ****     }
 279:../sdrx3.c    **** 
 280:../sdrx3.c    ****     /* Initialize the debug module. */
 281:../sdrx3.c    ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
 730              		.loc 1 281 0
 731 0458 0300A0E3 		mov	r0, #3
 732 045c 0810A0E3 		mov	r1, #8
 733 0460 FEFFFFEB 		bl	CyU3PDebugInit
 734 0464 08000BE5 		str	r0, [fp, #-8]
 282:../sdrx3.c    ****     if (apiRetStatus != CY_U3P_SUCCESS)
 735              		.loc 1 282 0
 736 0468 08301BE5 		ldr	r3, [fp, #-8]
 737 046c 000053E3 		cmp	r3, #0
 738 0470 0100000A 		beq	.L26
 283:../sdrx3.c    ****     {
 284:../sdrx3.c    ****         SDR_ErrorHandler(apiRetStatus);
 739              		.loc 1 284 0
 740 0474 08001BE5 		ldr	r0, [fp, #-8]
 741 0478 FEFFFFEB 		bl	SDR_ErrorHandler
 742              	.L26:
 285:../sdrx3.c    ****     }
 286:../sdrx3.c    **** 
 287:../sdrx3.c    ****     CyU3PDebugPreamble(CyFalse);
 743              		.loc 1 287 0
 744 047c 0000A0E3 		mov	r0, #0
 745 0480 FEFFFFEB 		bl	CyU3PDebugPreamble
 288:../sdrx3.c    **** }
 746              		.loc 1 288 0
 747 0484 04D04BE2 		sub	sp, fp, #4
 748              		@ sp needed
 749 0488 0088BDE8 		ldmfd	sp!, {fp, pc}
 750              	.L28:
 751              		.align	2
 752              	.L27:
 753 048c 00C20100 		.word	115200
 754              		.cfi_endproc
 755              	.LFE5:
 757              		.section	.rodata
 758 0067 00       		.align	2
 759              	.LC1:
 760 0068 4572726F 		.ascii	"Error! Invalid USB speed.\012\000"
 760      72212049 
 760      6E76616C 
 760      69642055 
 760      53422073 
 761 0083 00       		.align	2
 762              	.LC2:
 763 0084 43795533 		.ascii	"CyU3PSetEpConfig failed, Error code = %d\012\000"
 763      50536574 
 763      4570436F 
 763      6E666967 
 763      20666169 
 764 00ae 0000     		.align	2
 765              	.LC3:
 766 00b0 43795533 		.ascii	"CyU3PDmaChannelCreate failed, Error code = %d\012\000"
 766      50446D61 
 766      4368616E 
 766      6E656C43 
 766      72656174 
 767 00df 00       		.align	2
 768              	.LC4:
 769 00e0 43795533 		.ascii	"CyU3PDmaChannelSetXfer failed, Error code = %d\012\000"
 769      50446D61 
 769      4368616E 
 769      6E656C53 
 769      65745866 
 770              		.text
 771              		.align	2
 772              		.global	SDR_ApplnStart
 774              	SDR_ApplnStart:
 775              	.LFB6:
 289:../sdrx3.c    **** 
 290:../sdrx3.c    **** /* This function starts the application. This is called
 291:../sdrx3.c    ****  * when a SET_CONF event is received from the USB host. The endpoints
 292:../sdrx3.c    ****  * are configured and the DMA pipe is setup in this function. */
 293:../sdrx3.c    **** void
 294:../sdrx3.c    **** SDR_ApplnStart (
 295:../sdrx3.c    **** 		void)
 296:../sdrx3.c    **** {
 776              		.loc 1 296 0
 777              		.cfi_startproc
 778              		@ args = 0, pretend = 0, frame = 64
 779              		@ frame_needed = 1, uses_anonymous_args = 0
 780 0490 00482DE9 		stmfd	sp!, {fp, lr}
 781              	.LCFI12:
 782              		.cfi_def_cfa_offset 8
 783              		.cfi_offset 11, -8
 784              		.cfi_offset 14, -4
 785 0494 04B08DE2 		add	fp, sp, #4
 786              	.LCFI13:
 787              		.cfi_def_cfa 11, 4
 788 0498 40D04DE2 		sub	sp, sp, #64
 297:../sdrx3.c    **** 	uint16_t size = 0;
 789              		.loc 1 297 0
 790 049c 0030A0E3 		mov	r3, #0
 791 04a0 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 298:../sdrx3.c    **** 	CyU3PEpConfig_t epCfg;
 299:../sdrx3.c    **** 
 300:../sdrx3.c    **** 
 301:../sdrx3.c    **** 	CyU3PDmaMultiChannelConfig_t dmaCfg;
 302:../sdrx3.c    **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 792              		.loc 1 302 0
 793 04a4 0030A0E3 		mov	r3, #0
 794 04a8 0C300BE5 		str	r3, [fp, #-12]
 303:../sdrx3.c    **** 	CyU3PUSBSpeed_t usbSpeed = CyU3PUsbGetSpeed();
 795              		.loc 1 303 0
 796 04ac FEFFFFEB 		bl	CyU3PUsbGetSpeed
 797 04b0 0030A0E1 		mov	r3, r0
 798 04b4 0D304BE5 		strb	r3, [fp, #-13]
 304:../sdrx3.c    **** 
 305:../sdrx3.c    **** 	/* First identify the usb speed. Once that is identified,
 306:../sdrx3.c    **** 	 * create a DMA channel and start the transfer on this. */
 307:../sdrx3.c    **** 
 308:../sdrx3.c    **** 	/* Based on the Bus Speed configure the endpoint packet size */
 309:../sdrx3.c    **** 	switch (usbSpeed)
 799              		.loc 1 309 0
 800 04b8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 801 04bc 020053E3 		cmp	r3, #2
 802 04c0 0600000A 		beq	.L31
 803 04c4 030053E3 		cmp	r3, #3
 804 04c8 0700000A 		beq	.L32
 805 04cc 010053E3 		cmp	r3, #1
 806 04d0 0800001A 		bne	.L40
 310:../sdrx3.c    **** 	{
 311:../sdrx3.c    **** 	case CY_U3P_FULL_SPEED:
 312:../sdrx3.c    **** 		size = 64;
 807              		.loc 1 312 0
 808 04d4 4030A0E3 		mov	r3, #64
 809 04d8 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 313:../sdrx3.c    **** 		break;
 810              		.loc 1 313 0
 811 04dc 0B0000EA 		b	.L34
 812              	.L31:
 314:../sdrx3.c    **** 
 315:../sdrx3.c    **** 	case CY_U3P_HIGH_SPEED:
 316:../sdrx3.c    **** 		size = 512;
 813              		.loc 1 316 0
 814 04e0 023CA0E3 		mov	r3, #512
 815 04e4 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 317:../sdrx3.c    **** 		break;
 816              		.loc 1 317 0
 817 04e8 080000EA 		b	.L34
 818              	.L32:
 318:../sdrx3.c    **** 
 319:../sdrx3.c    **** 	case CY_U3P_SUPER_SPEED:
 320:../sdrx3.c    **** 		size = 1024;
 819              		.loc 1 320 0
 820 04ec 013BA0E3 		mov	r3, #1024
 821 04f0 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 321:../sdrx3.c    **** 		break;
 822              		.loc 1 321 0
 823 04f4 050000EA 		b	.L34
 824              	.L40:
 322:../sdrx3.c    **** 
 323:../sdrx3.c    **** 	default:
 324:../sdrx3.c    **** 		CyU3PDebugPrint (4, "Error! Invalid USB speed.\n");
 825              		.loc 1 324 0
 826 04f8 0400A0E3 		mov	r0, #4
 827 04fc AC119FE5 		ldr	r1, .L41
 828 0500 FEFFFFEB 		bl	CyU3PDebugPrint
 325:../sdrx3.c    **** 		SDR_ErrorHandler (CY_U3P_ERROR_FAILURE);
 829              		.loc 1 325 0
 830 0504 4A00A0E3 		mov	r0, #74
 831 0508 FEFFFFEB 		bl	SDR_ErrorHandler
 326:../sdrx3.c    **** 		break;
 832              		.loc 1 326 0
 833 050c 0000A0E1 		mov	r0, r0	@ nop
 834              	.L34:
 327:../sdrx3.c    **** 	}
 328:../sdrx3.c    **** 
 329:../sdrx3.c    **** 	CyU3PMemSet ((uint8_t *)&epCfg, 0, sizeof (epCfg));
 835              		.loc 1 329 0
 836 0510 1C304BE2 		sub	r3, fp, #28
 837 0514 0300A0E1 		mov	r0, r3
 838 0518 0010A0E3 		mov	r1, #0
 839 051c 0C20A0E3 		mov	r2, #12
 840 0520 FEFFFFEB 		bl	CyU3PMemSet
 330:../sdrx3.c    **** 	epCfg.enable = CyTrue;
 841              		.loc 1 330 0
 842 0524 0130A0E3 		mov	r3, #1
 843 0528 1C300BE5 		str	r3, [fp, #-28]
 331:../sdrx3.c    **** 	epCfg.epType = CY_U3P_USB_EP_BULK;
 844              		.loc 1 331 0
 845 052c 0230A0E3 		mov	r3, #2
 846 0530 18304BE5 		strb	r3, [fp, #-24]
 332:../sdrx3.c    **** 	epCfg.burstLen = (usbSpeed == CY_U3P_SUPER_SPEED) ?
 847              		.loc 1 332 0
 848 0534 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 849 0538 030053E3 		cmp	r3, #3
 850 053c 0100001A 		bne	.L35
 851              		.loc 1 332 0 is_stmt 0 discriminator 1
 852 0540 0830A0E3 		mov	r3, #8
 853 0544 000000EA 		b	.L36
 854              	.L35:
 855              		.loc 1 332 0 discriminator 2
 856 0548 0130A0E3 		mov	r3, #1
 857              	.L36:
 858              		.loc 1 332 0 discriminator 3
 859 054c 12304BE5 		strb	r3, [fp, #-18]
 333:../sdrx3.c    **** 			(CY_FX_EP_BURST_LENGTH) : 1;
 334:../sdrx3.c    **** 	epCfg.streams = 0;
 860              		.loc 1 334 0 is_stmt 1 discriminator 3
 861 0550 0030A0E3 		mov	r3, #0
 862 0554 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 335:../sdrx3.c    **** 	epCfg.pcktSize = size;
 863              		.loc 1 335 0 discriminator 3
 864 0558 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 865 055c B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 336:../sdrx3.c    **** 
 337:../sdrx3.c    **** 	/* Consumer endpoint configuration */
 338:../sdrx3.c    **** 	apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_CONSUMER, &epCfg);
 866              		.loc 1 338 0 discriminator 3
 867 0560 1C304BE2 		sub	r3, fp, #28
 868 0564 8100A0E3 		mov	r0, #129
 869 0568 0310A0E1 		mov	r1, r3
 870 056c FEFFFFEB 		bl	CyU3PSetEpConfig
 871 0570 0C000BE5 		str	r0, [fp, #-12]
 339:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 872              		.loc 1 339 0 discriminator 3
 873 0574 0C301BE5 		ldr	r3, [fp, #-12]
 874 0578 000053E3 		cmp	r3, #0
 875 057c 0500000A 		beq	.L37
 340:../sdrx3.c    **** 	{
 341:../sdrx3.c    **** 		CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 876              		.loc 1 341 0
 877 0580 0400A0E3 		mov	r0, #4
 878 0584 28119FE5 		ldr	r1, .L41+4
 879 0588 0C201BE5 		ldr	r2, [fp, #-12]
 880 058c FEFFFFEB 		bl	CyU3PDebugPrint
 342:../sdrx3.c    **** 		SDR_ErrorHandler (apiRetStatus);
 881              		.loc 1 342 0
 882 0590 0C001BE5 		ldr	r0, [fp, #-12]
 883 0594 FEFFFFEB 		bl	SDR_ErrorHandler
 884              	.L37:
 343:../sdrx3.c    **** 	}
 344:../sdrx3.c    **** 
 345:../sdrx3.c    **** 	/* Create a DMA MANUAL_IN channel for the producer socket. */
 346:../sdrx3.c    **** 	CyU3PMemSet ((uint8_t *)&dmaCfg, 0, sizeof (dmaCfg));
 885              		.loc 1 346 0
 886 0598 44304BE2 		sub	r3, fp, #68
 887 059c 0300A0E1 		mov	r0, r3
 888 05a0 0010A0E3 		mov	r1, #0
 889 05a4 2820A0E3 		mov	r2, #40
 890 05a8 FEFFFFEB 		bl	CyU3PMemSet
 347:../sdrx3.c    **** 	/* The buffer size will be same as packet size for the
 348:../sdrx3.c    **** 	 * full speed, high speed and super speed non-burst modes.
 349:../sdrx3.c    **** 	 * For super speed burst mode of operation, the buffers will be
 350:../sdrx3.c    **** 	 * 1024 * burst length so that a full burst can be completed.
 351:../sdrx3.c    **** 	 * This will mean that a buffer will be available only after it
 352:../sdrx3.c    **** 	 * has been filled or when a short packet is received. */
 353:../sdrx3.c    **** 
 354:../sdrx3.c    **** 	dmaCfg.size  = (size * CY_FX_EP_BURST_LENGTH );  // 16 * 1024   !!!!!!!!!!
 891              		.loc 1 354 0
 892 05ac B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 893 05b0 8331A0E1 		mov	r3, r3, asl #3
 894 05b4 0338A0E1 		mov	r3, r3, asl #16
 895 05b8 2338A0E1 		mov	r3, r3, lsr #16
 896 05bc B4344BE1 		strh	r3, [fp, #-68]	@ movhi
 355:../sdrx3.c    **** 	dmaCfg.count = CY_FX_BULKSRCSINK_DMA_BUF_COUNT;  // 6
 897              		.loc 1 355 0
 898 05c0 0630A0E3 		mov	r3, #6
 899 05c4 B2344BE1 		strh	r3, [fp, #-66]	@ movhi
 356:../sdrx3.c    **** 	dmaCfg.validSckCount = 2;
 900              		.loc 1 356 0
 901 05c8 0230A0E3 		mov	r3, #2
 902 05cc B0344BE1 		strh	r3, [fp, #-64]	@ movhi
 357:../sdrx3.c    **** 
 358:../sdrx3.c    **** 	dmaCfg.dmaMode = CY_U3P_DMA_MODE_BYTE;  		// 2
 903              		.loc 1 358 0
 904 05d0 0030A0E3 		mov	r3, #0
 905 05d4 26304BE5 		strb	r3, [fp, #-38]
 359:../sdrx3.c    **** 	dmaCfg.notification = 0;
 906              		.loc 1 359 0
 907 05d8 0030A0E3 		mov	r3, #0
 908 05dc 24300BE5 		str	r3, [fp, #-36]
 360:../sdrx3.c    **** 	dmaCfg.cb = NULL;
 909              		.loc 1 360 0
 910 05e0 0030A0E3 		mov	r3, #0
 911 05e4 20300BE5 		str	r3, [fp, #-32]
 361:../sdrx3.c    **** 	dmaCfg.prodHeader = 0;
 912              		.loc 1 361 0
 913 05e8 0030A0E3 		mov	r3, #0
 914 05ec BC324BE1 		strh	r3, [fp, #-44]	@ movhi
 362:../sdrx3.c    **** 	dmaCfg.prodFooter = 0;
 915              		.loc 1 362 0
 916 05f0 0030A0E3 		mov	r3, #0
 917 05f4 BA324BE1 		strh	r3, [fp, #-42]	@ movhi
 363:../sdrx3.c    **** 	dmaCfg.consHeader = 0;
 918              		.loc 1 363 0
 919 05f8 0030A0E3 		mov	r3, #0
 920 05fc B8324BE1 		strh	r3, [fp, #-40]	@ movhi
 364:../sdrx3.c    **** 	dmaCfg.prodAvailCount = 0;
 921              		.loc 1 364 0
 922 0600 0030A0E3 		mov	r3, #0
 923 0604 BE324BE1 		strh	r3, [fp, #-46]	@ movhi
 365:../sdrx3.c    **** 
 366:../sdrx3.c    **** 	/* Create a DMA MANUAL_OUT channel for the consumer socket. */
 367:../sdrx3.c    **** 	dmaCfg.prodSckId[0] = CY_U3P_PIB_SOCKET_0;
 924              		.loc 1 367 0
 925 0608 013CA0E3 		mov	r3, #256
 926 060c BE334BE1 		strh	r3, [fp, #-62]	@ movhi
 368:../sdrx3.c    **** 	dmaCfg.prodSckId[1] = CY_U3P_PIB_SOCKET_1;
 927              		.loc 1 368 0
 928 0610 A0309FE5 		ldr	r3, .L41+8
 929 0614 BC334BE1 		strh	r3, [fp, #-60]	@ movhi
 369:../sdrx3.c    **** 	dmaCfg.consSckId[0] = CY_FX_EP_CONSUMER_SOCKET;
 930              		.loc 1 369 0
 931 0618 9C309FE5 		ldr	r3, .L41+12
 932 061c B6334BE1 		strh	r3, [fp, #-54]	@ movhi
 370:../sdrx3.c    **** 
 371:../sdrx3.c    **** 	apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleBulkSrc, CY_U3P_DMA_TYPE_AUTO_MANY_TO_ONE , 
 933              		.loc 1 371 0
 934 0620 44304BE2 		sub	r3, fp, #68
 935 0624 94009FE5 		ldr	r0, .L41+16
 936 0628 0510A0E3 		mov	r1, #5
 937 062c 0320A0E1 		mov	r2, r3
 938 0630 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 939 0634 0C000BE5 		str	r0, [fp, #-12]
 372:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 940              		.loc 1 372 0
 941 0638 0C301BE5 		ldr	r3, [fp, #-12]
 942 063c 000053E3 		cmp	r3, #0
 943 0640 0500000A 		beq	.L38
 373:../sdrx3.c    **** 	{
 374:../sdrx3.c    **** 		CyU3PDebugPrint (4, "CyU3PDmaChannelCreate failed, Error code = %d\n", apiRetStatus);
 944              		.loc 1 374 0
 945 0644 0400A0E3 		mov	r0, #4
 946 0648 74109FE5 		ldr	r1, .L41+20
 947 064c 0C201BE5 		ldr	r2, [fp, #-12]
 948 0650 FEFFFFEB 		bl	CyU3PDebugPrint
 375:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 949              		.loc 1 375 0
 950 0654 0C001BE5 		ldr	r0, [fp, #-12]
 951 0658 FEFFFFEB 		bl	SDR_ErrorHandler
 952              	.L38:
 376:../sdrx3.c    **** 	}
 377:../sdrx3.c    **** 
 378:../sdrx3.c    **** 	/* Set DMA Channel transfer size */
 379:../sdrx3.c    **** 
 380:../sdrx3.c    **** 	apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleBulkSrc, CY_FX_BULKSRCSINK_DMA_TX_SIZE, 0);
 953              		.loc 1 380 0
 954 065c 5C009FE5 		ldr	r0, .L41+16
 955 0660 0010A0E3 		mov	r1, #0
 956 0664 0020A0E3 		mov	r2, #0
 957 0668 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 958 066c 0C000BE5 		str	r0, [fp, #-12]
 381:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 959              		.loc 1 381 0
 960 0670 0C301BE5 		ldr	r3, [fp, #-12]
 961 0674 000053E3 		cmp	r3, #0
 962 0678 0500000A 		beq	.L39
 382:../sdrx3.c    **** 	{
 383:../sdrx3.c    **** 		CyU3PDebugPrint (4, "CyU3PDmaChannelSetXfer failed, Error code = %d\n", apiRetStatus);
 963              		.loc 1 383 0
 964 067c 0400A0E3 		mov	r0, #4
 965 0680 40109FE5 		ldr	r1, .L41+24
 966 0684 0C201BE5 		ldr	r2, [fp, #-12]
 967 0688 FEFFFFEB 		bl	CyU3PDebugPrint
 384:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 968              		.loc 1 384 0
 969 068c 0C001BE5 		ldr	r0, [fp, #-12]
 970 0690 FEFFFFEB 		bl	SDR_ErrorHandler
 971              	.L39:
 385:../sdrx3.c    **** 	}
 386:../sdrx3.c    **** 
 387:../sdrx3.c    **** 	/* Flush the endpoint memory */
 388:../sdrx3.c    **** 		CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 972              		.loc 1 388 0
 973 0694 8100A0E3 		mov	r0, #129
 974 0698 FEFFFFEB 		bl	CyU3PUsbFlushEp
 389:../sdrx3.c    **** 
 390:../sdrx3.c    **** 	glIsApplnActive = CyTrue;
 975              		.loc 1 390 0
 976 069c 28309FE5 		ldr	r3, .L41+28
 977 06a0 0120A0E3 		mov	r2, #1
 978 06a4 002083E5 		str	r2, [r3]
 391:../sdrx3.c    **** }
 979              		.loc 1 391 0
 980 06a8 04D04BE2 		sub	sp, fp, #4
 981              		@ sp needed
 982 06ac 0088BDE8 		ldmfd	sp!, {fp, pc}
 983              	.L42:
 984              		.align	2
 985              	.L41:
 986 06b0 68000000 		.word	.LC1
 987 06b4 84000000 		.word	.LC2
 988 06b8 01010000 		.word	257
 989 06bc 01030000 		.word	769
 990 06c0 00000000 		.word	glChHandleBulkSrc
 991 06c4 B0000000 		.word	.LC3
 992 06c8 E0000000 		.word	.LC4
 993 06cc 00000000 		.word	glIsApplnActive
 994              		.cfi_endproc
 995              	.LFE6:
 997              		.align	2
 998              		.global	SDR_ApplnStop
 1000              	SDR_ApplnStop:
 1001              	.LFB7:
 392:../sdrx3.c    **** 
 393:../sdrx3.c    **** /* This function stops the application. This shall be called whenever a RESET
 394:../sdrx3.c    ****  * or DISCONNECT event is received from the USB host. The endpoints are
 395:../sdrx3.c    ****  * disabled and the DMA pipe is destroyed by this function. */
 396:../sdrx3.c    **** void
 397:../sdrx3.c    **** SDR_ApplnStop (
 398:../sdrx3.c    **** 		void)
 399:../sdrx3.c    **** {
 1002              		.loc 1 399 0
 1003              		.cfi_startproc
 1004              		@ args = 0, pretend = 0, frame = 16
 1005              		@ frame_needed = 1, uses_anonymous_args = 0
 1006 06d0 00482DE9 		stmfd	sp!, {fp, lr}
 1007              	.LCFI14:
 1008              		.cfi_def_cfa_offset 8
 1009              		.cfi_offset 11, -8
 1010              		.cfi_offset 14, -4
 1011 06d4 04B08DE2 		add	fp, sp, #4
 1012              	.LCFI15:
 1013              		.cfi_def_cfa 11, 4
 1014 06d8 10D04DE2 		sub	sp, sp, #16
 400:../sdrx3.c    **** 	CyU3PEpConfig_t epCfg;
 401:../sdrx3.c    **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 1015              		.loc 1 401 0
 1016 06dc 0030A0E3 		mov	r3, #0
 1017 06e0 08300BE5 		str	r3, [fp, #-8]
 402:../sdrx3.c    **** 
 403:../sdrx3.c    **** 	/* Update the flag so that the application thread is notified of this. */
 404:../sdrx3.c    **** 	glIsApplnActive = CyFalse;
 1018              		.loc 1 404 0
 1019 06e4 70309FE5 		ldr	r3, .L45
 1020 06e8 0020A0E3 		mov	r2, #0
 1021 06ec 002083E5 		str	r2, [r3]
 405:../sdrx3.c    **** 
 406:../sdrx3.c    **** 	/* Disable endpoints. */
 407:../sdrx3.c    **** 	CyU3PMemSet ((uint8_t *)&epCfg, 0, sizeof (epCfg));
 1022              		.loc 1 407 0
 1023 06f0 14304BE2 		sub	r3, fp, #20
 1024 06f4 0300A0E1 		mov	r0, r3
 1025 06f8 0010A0E3 		mov	r1, #0
 1026 06fc 0C20A0E3 		mov	r2, #12
 1027 0700 FEFFFFEB 		bl	CyU3PMemSet
 408:../sdrx3.c    **** 	epCfg.enable = CyFalse;
 1028              		.loc 1 408 0
 1029 0704 0030A0E3 		mov	r3, #0
 1030 0708 14300BE5 		str	r3, [fp, #-20]
 409:../sdrx3.c    **** 
 410:../sdrx3.c    **** 	CyU3PDmaMultiChannelDestroy (&glChHandleBulkSrc);
 1031              		.loc 1 410 0
 1032 070c 4C009FE5 		ldr	r0, .L45+4
 1033 0710 FEFFFFEB 		bl	CyU3PDmaMultiChannelDestroy
 411:../sdrx3.c    **** 	CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 1034              		.loc 1 411 0
 1035 0714 8100A0E3 		mov	r0, #129
 1036 0718 FEFFFFEB 		bl	CyU3PUsbFlushEp
 412:../sdrx3.c    **** 	/* Consumer endpoint configuration. */
 413:../sdrx3.c    **** 	apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_CONSUMER, &epCfg);
 1037              		.loc 1 413 0
 1038 071c 14304BE2 		sub	r3, fp, #20
 1039 0720 8100A0E3 		mov	r0, #129
 1040 0724 0310A0E1 		mov	r1, r3
 1041 0728 FEFFFFEB 		bl	CyU3PSetEpConfig
 1042 072c 08000BE5 		str	r0, [fp, #-8]
 414:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1043              		.loc 1 414 0
 1044 0730 08301BE5 		ldr	r3, [fp, #-8]
 1045 0734 000053E3 		cmp	r3, #0
 1046 0738 0500000A 		beq	.L43
 415:../sdrx3.c    **** 	{
 416:../sdrx3.c    **** 		CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 1047              		.loc 1 416 0
 1048 073c 0400A0E3 		mov	r0, #4
 1049 0740 1C109FE5 		ldr	r1, .L45+8
 1050 0744 08201BE5 		ldr	r2, [fp, #-8]
 1051 0748 FEFFFFEB 		bl	CyU3PDebugPrint
 417:../sdrx3.c    **** 		SDR_ErrorHandler (apiRetStatus);
 1052              		.loc 1 417 0
 1053 074c 08001BE5 		ldr	r0, [fp, #-8]
 1054 0750 FEFFFFEB 		bl	SDR_ErrorHandler
 1055              	.L43:
 418:../sdrx3.c    **** 	}
 419:../sdrx3.c    **** 
 420:../sdrx3.c    **** }
 1056              		.loc 1 420 0
 1057 0754 04D04BE2 		sub	sp, fp, #4
 1058              		@ sp needed
 1059 0758 0088BDE8 		ldmfd	sp!, {fp, pc}
 1060              	.L46:
 1061              		.align	2
 1062              	.L45:
 1063 075c 00000000 		.word	glIsApplnActive
 1064 0760 00000000 		.word	glChHandleBulkSrc
 1065 0764 84000000 		.word	.LC2
 1066              		.cfi_endproc
 1067              	.LFE7:
 1069              		.section	.rodata
 1070              		.align	2
 1071              	.LC5:
 1072 0110 0A204359 		.ascii	"\012 CY_FX_RQT_GPIO_PWM failed, error code = %d\012"
 1072      5F46585F 
 1072      5251545F 
 1072      4750494F 
 1072      5F50574D 
 1073 013d 00       		.ascii	"\000"
 1074 013e 0000     		.align	2
 1075              	.LC6:
 1076 0140 0A0D4359 		.ascii	"\012\015CY_FX_RQT_I2C_WRITE failed, error code = 0x"
 1076      5F46585F 
 1076      5251545F 
 1076      4932435F 
 1076      57524954 
 1077 016d 25580A00 		.ascii	"%X\012\000"
 1078 0171 000000   		.align	2
 1079              	.LC7:
 1080 0174 0A0D4359 		.ascii	"\012\015CY_FX_RQT_I2C_READ failed, error code = 0x%"
 1080      5F46585F 
 1080      5251545F 
 1080      4932435F 
 1080      52454144 
 1081 01a1 580A00   		.ascii	"X\012\000"
 1082              		.text
 1083              		.align	2
 1084              		.global	SDR_ApplnUSBSetupCB
 1086              	SDR_ApplnUSBSetupCB:
 1087              	.LFB8:
 421:../sdrx3.c    **** 
 422:../sdrx3.c    **** /* Callback to handle the USB setup requests. */
 423:../sdrx3.c    **** CyBool_t
 424:../sdrx3.c    **** SDR_ApplnUSBSetupCB (
 425:../sdrx3.c    **** 		uint32_t setupdat0, /* SETUP Data 0 */
 426:../sdrx3.c    **** 		uint32_t setupdat1  /* SETUP Data 1 */
 427:../sdrx3.c    **** )
 428:../sdrx3.c    **** {
 1088              		.loc 1 428 0
 1089              		.cfi_startproc
 1090              		@ args = 0, pretend = 0, frame = 40
 1091              		@ frame_needed = 1, uses_anonymous_args = 0
 1092 0768 00482DE9 		stmfd	sp!, {fp, lr}
 1093              	.LCFI16:
 1094              		.cfi_def_cfa_offset 8
 1095              		.cfi_offset 11, -8
 1096              		.cfi_offset 14, -4
 1097 076c 04B08DE2 		add	fp, sp, #4
 1098              	.LCFI17:
 1099              		.cfi_def_cfa 11, 4
 1100 0770 30D04DE2 		sub	sp, sp, #48
 1101 0774 28000BE5 		str	r0, [fp, #-40]
 1102 0778 2C100BE5 		str	r1, [fp, #-44]
 429:../sdrx3.c    **** 	uint8_t  bRequest, bReqType;
 430:../sdrx3.c    **** 	uint8_t  bType; // bTarget;
 431:../sdrx3.c    **** 	uint16_t wValue;
 432:../sdrx3.c    **** 	uint16_t wLength;
 433:../sdrx3.c    **** 	uint16_t wIndex;
 434:../sdrx3.c    ****     outxio_t * pdata;
 435:../sdrx3.c    ****     pwmxio_t * ppwm;
 436:../sdrx3.c    ****     uint32_t value;
 437:../sdrx3.c    ****     CyU3PReturnStatus_t apiRetStatus = 0;
 1103              		.loc 1 437 0
 1104 077c 0030A0E3 		mov	r3, #0
 1105 0780 10300BE5 		str	r3, [fp, #-16]
 438:../sdrx3.c    ****     CyBool_t isHandled = CyFalse;
 1106              		.loc 1 438 0
 1107 0784 0030A0E3 		mov	r3, #0
 1108 0788 14300BE5 		str	r3, [fp, #-20]
 439:../sdrx3.c    **** 
 440:../sdrx3.c    **** 
 441:../sdrx3.c    **** 	/* Decode the fields from the setup request. */
 442:../sdrx3.c    **** 	bReqType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 1109              		.loc 1 442 0
 1110 078c 28301BE5 		ldr	r3, [fp, #-40]
 1111 0790 15304BE5 		strb	r3, [fp, #-21]
 443:../sdrx3.c    **** 	bType    = (bReqType & CY_U3P_USB_TYPE_MASK);
 1112              		.loc 1 443 0
 1113 0794 15305BE5 		ldrb	r3, [fp, #-21]
 1114 0798 603003E2 		and	r3, r3, #96
 1115 079c 16304BE5 		strb	r3, [fp, #-22]
 444:../sdrx3.c    **** //	bTarget  = (bReqType & CY_U3P_USB_TARGET_MASK);
 445:../sdrx3.c    **** 	bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 1116              		.loc 1 445 0
 1117 07a0 28301BE5 		ldr	r3, [fp, #-40]
 1118 07a4 FF3C03E2 		and	r3, r3, #65280
 1119 07a8 2334A0E1 		mov	r3, r3, lsr #8
 1120 07ac 17304BE5 		strb	r3, [fp, #-23]
 446:../sdrx3.c    **** 	wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
 1121              		.loc 1 446 0
 1122 07b0 28301BE5 		ldr	r3, [fp, #-40]
 1123 07b4 2338A0E1 		mov	r3, r3, lsr #16
 1124 07b8 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 447:../sdrx3.c    **** 	wLength   = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)   >> CY_U3P_USB_LENGTH_POS);
 1125              		.loc 1 447 0
 1126 07bc 2C301BE5 		ldr	r3, [fp, #-44]
 1127 07c0 2338A0E1 		mov	r3, r3, lsr #16
 1128 07c4 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 448:../sdrx3.c    **** 	wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
 1129              		.loc 1 448 0
 1130 07c8 2C301BE5 		ldr	r3, [fp, #-44]
 1131 07cc BC314BE1 		strh	r3, [fp, #-28]	@ movhi
 449:../sdrx3.c    **** 
 450:../sdrx3.c    **** 
 451:../sdrx3.c    **** 	if (bType == CY_U3P_USB_VENDOR_RQT)
 1132              		.loc 1 451 0
 1133 07d0 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 1134 07d4 400053E3 		cmp	r3, #64
 1135 07d8 DE00001A 		bne	.L48
 452:../sdrx3.c    **** 	{
 453:../sdrx3.c    **** 		isHandled = CyTrue;
 1136              		.loc 1 453 0
 1137 07dc 0130A0E3 		mov	r3, #1
 1138 07e0 14300BE5 		str	r3, [fp, #-20]
 454:../sdrx3.c    **** 		switch (bRequest)
 1139              		.loc 1 454 0
 1140 07e4 17305BE5 		ldrb	r3, [fp, #-23]	@ zero_extendqisi2
 1141 07e8 B03043E2 		sub	r3, r3, #176
 1142 07ec 0D0053E3 		cmp	r3, #13
 1143 07f0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1144 07f4 D20000EA 		b	.L49
 1145              	.L51:
 1146 07f8 30080000 		.word	.L50
 1147 07fc 440B0000 		.word	.L49
 1148 0800 440B0000 		.word	.L49
 1149 0804 440B0000 		.word	.L49
 1150 0808 440B0000 		.word	.L49
 1151 080c 440B0000 		.word	.L49
 1152 0810 440B0000 		.word	.L49
 1153 0814 440B0000 		.word	.L49
 1154 0818 440B0000 		.word	.L49
 1155 081c 440B0000 		.word	.L49
 1156 0820 180A0000 		.word	.L52
 1157 0824 9C0A0000 		.word	.L53
 1158 0828 40080000 		.word	.L54
 1159 082c 88090000 		.word	.L55
 1160              	.L50:
 455:../sdrx3.c    **** 		{
 456:../sdrx3.c    **** 			case CY_FX_RQT_ID_CHECK:
 457:../sdrx3.c    **** 				CyU3PUsbSendEP0Data (8, (uint8_t *)glFirmwareID);
 1161              		.loc 1 457 0
 1162 0830 0800A0E3 		mov	r0, #8
 1163 0834 2C139FE5 		ldr	r1, .L65
 1164 0838 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 458:../sdrx3.c    **** 				break;
 1165              		.loc 1 458 0
 1166 083c C30000EA 		b	.L56
 1167              	.L54:
 459:../sdrx3.c    **** 
 460:../sdrx3.c    **** 			case CY_FX_RQT_GPIO_WRITE:
 461:../sdrx3.c    **** 				if(CyU3PUsbGetEP0Data(wLength, glEp0Buffer, NULL)== CY_U3P_SUCCESS)
 1168              		.loc 1 461 0
 1169 0840 B6305BE1 		ldrh	r3, [fp, #-6]
 1170 0844 0300A0E1 		mov	r0, r3
 1171 0848 1C139FE5 		ldr	r1, .L65+4
 1172 084c 0020A0E3 		mov	r2, #0
 1173 0850 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1174 0854 0030A0E1 		mov	r3, r0
 1175 0858 000053E3 		cmp	r3, #0
 1176 085c 4800001A 		bne	.L57
 462:../sdrx3.c    **** 				{
 463:../sdrx3.c    **** 					pdata = (outxio_t *) &glEp0Buffer[1];
 1177              		.loc 1 463 0
 1178 0860 08339FE5 		ldr	r3, .L65+8
 1179 0864 20300BE5 		str	r3, [fp, #-32]
 464:../sdrx3.c    **** 					CyU3PGpioSetValue (21, (pdata->buffer[0] & OUTXIO0) == OUTXIO0 );
 1180              		.loc 1 464 0
 1181 0868 20301BE5 		ldr	r3, [fp, #-32]
 1182 086c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1183 0870 013003E2 		and	r3, r3, #1
 1184 0874 000053E3 		cmp	r3, #0
 1185 0878 0030A003 		moveq	r3, #0
 1186 087c 0130A013 		movne	r3, #1
 1187 0880 FF3003E2 		and	r3, r3, #255
 1188 0884 1500A0E3 		mov	r0, #21
 1189 0888 0310A0E1 		mov	r1, r3
 1190 088c FEFFFFEB 		bl	CyU3PGpioSetValue
 465:../sdrx3.c    **** 					CyU3PGpioSetValue (22, (pdata->buffer[0] & OUTXIO1) == OUTXIO1 );
 1191              		.loc 1 465 0
 1192 0890 20301BE5 		ldr	r3, [fp, #-32]
 1193 0894 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1194 0898 023003E2 		and	r3, r3, #2
 1195 089c 000053E3 		cmp	r3, #0
 1196 08a0 0030A003 		moveq	r3, #0
 1197 08a4 0130A013 		movne	r3, #1
 1198 08a8 FF3003E2 		and	r3, r3, #255
 1199 08ac 1600A0E3 		mov	r0, #22
 1200 08b0 0310A0E1 		mov	r1, r3
 1201 08b4 FEFFFFEB 		bl	CyU3PGpioSetValue
 466:../sdrx3.c    **** 					CyU3PGpioSetValue (23, (pdata->buffer[0] & OUTXIO2) == OUTXIO2 );
 1202              		.loc 1 466 0
 1203 08b8 20301BE5 		ldr	r3, [fp, #-32]
 1204 08bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1205 08c0 043003E2 		and	r3, r3, #4
 1206 08c4 000053E3 		cmp	r3, #0
 1207 08c8 0030A003 		moveq	r3, #0
 1208 08cc 0130A013 		movne	r3, #1
 1209 08d0 FF3003E2 		and	r3, r3, #255
 1210 08d4 1700A0E3 		mov	r0, #23
 1211 08d8 0310A0E1 		mov	r1, r3
 1212 08dc FEFFFFEB 		bl	CyU3PGpioSetValue
 467:../sdrx3.c    **** 					CyU3PGpioSetValue (26, (pdata->buffer[0] & OUTXIO3) == OUTXIO3 );
 1213              		.loc 1 467 0
 1214 08e0 20301BE5 		ldr	r3, [fp, #-32]
 1215 08e4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1216 08e8 083003E2 		and	r3, r3, #8
 1217 08ec 000053E3 		cmp	r3, #0
 1218 08f0 0030A003 		moveq	r3, #0
 1219 08f4 0130A013 		movne	r3, #1
 1220 08f8 FF3003E2 		and	r3, r3, #255
 1221 08fc 1A00A0E3 		mov	r0, #26
 1222 0900 0310A0E1 		mov	r1, r3
 1223 0904 FEFFFFEB 		bl	CyU3PGpioSetValue
 468:../sdrx3.c    **** 					CyU3PGpioSetValue (27, (pdata->buffer[0] & OUTXIO4) == OUTXIO4 );
 1224              		.loc 1 468 0
 1225 0908 20301BE5 		ldr	r3, [fp, #-32]
 1226 090c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1227 0910 103003E2 		and	r3, r3, #16
 1228 0914 000053E3 		cmp	r3, #0
 1229 0918 0030A003 		moveq	r3, #0
 1230 091c 0130A013 		movne	r3, #1
 1231 0920 FF3003E2 		and	r3, r3, #255
 1232 0924 1B00A0E3 		mov	r0, #27
 1233 0928 0310A0E1 		mov	r1, r3
 1234 092c FEFFFFEB 		bl	CyU3PGpioSetValue
 469:../sdrx3.c    **** 					CyU3PGpioSetValue (28, (pdata->buffer[0] & OUTXIO5) == OUTXIO5 );
 1235              		.loc 1 469 0
 1236 0930 20301BE5 		ldr	r3, [fp, #-32]
 1237 0934 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1238 0938 203003E2 		and	r3, r3, #32
 1239 093c 000053E3 		cmp	r3, #0
 1240 0940 0030A003 		moveq	r3, #0
 1241 0944 0130A013 		movne	r3, #1
 1242 0948 FF3003E2 		and	r3, r3, #255
 1243 094c 1C00A0E3 		mov	r0, #28
 1244 0950 0310A0E1 		mov	r1, r3
 1245 0954 FEFFFFEB 		bl	CyU3PGpioSetValue
 470:../sdrx3.c    **** 					CyU3PGpioSetValue (29, (pdata->buffer[0] & OUTXIO6) == OUTXIO6 );
 1246              		.loc 1 470 0
 1247 0958 20301BE5 		ldr	r3, [fp, #-32]
 1248 095c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1249 0960 403003E2 		and	r3, r3, #64
 1250 0964 000053E3 		cmp	r3, #0
 1251 0968 0030A003 		moveq	r3, #0
 1252 096c 0130A013 		movne	r3, #1
 1253 0970 FF3003E2 		and	r3, r3, #255
 1254 0974 1D00A0E3 		mov	r0, #29
 1255 0978 0310A0E1 		mov	r1, r3
 1256 097c FEFFFFEB 		bl	CyU3PGpioSetValue
 471:../sdrx3.c    **** 				}
 472:../sdrx3.c    **** 				break;
 1257              		.loc 1 472 0
 1258 0980 720000EA 		b	.L56
 1259              	.L57:
 1260 0984 710000EA 		b	.L56
 1261              	.L55:
 473:../sdrx3.c    **** 
 474:../sdrx3.c    **** 			case CY_FX_RQT_GPIO_PWM:
 475:../sdrx3.c    **** 				if(CyU3PUsbGetEP0Data(wLength, glEp0Buffer, NULL)== CY_U3P_SUCCESS)
 1262              		.loc 1 475 0
 1263 0988 B6305BE1 		ldrh	r3, [fp, #-6]
 1264 098c 0300A0E1 		mov	r0, r3
 1265 0990 D4119FE5 		ldr	r1, .L65+4
 1266 0994 0020A0E3 		mov	r2, #0
 1267 0998 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1268 099c 0030A0E1 		mov	r3, r0
 1269 09a0 000053E3 		cmp	r3, #0
 1270 09a4 1A00001A 		bne	.L58
 476:../sdrx3.c    **** 				{
 477:../sdrx3.c    **** 					ppwm = (pwmxio_t *)&glEp0Buffer[1];
 1271              		.loc 1 477 0
 1272 09a8 C0319FE5 		ldr	r3, .L65+8
 1273 09ac 24300BE5 		str	r3, [fp, #-36]
 478:../sdrx3.c    **** 					value = ppwm->dutycicle;
 1274              		.loc 1 478 0
 1275 09b0 24301BE5 		ldr	r3, [fp, #-36]
 1276 09b4 003093E5 		ldr	r3, [r3]
 1277 09b8 0C300BE5 		str	r3, [fp, #-12]
 479:../sdrx3.c    **** 					if (value >= CY_FX_PWM_PERIOD)
 1278              		.loc 1 479 0
 1279 09bc 0C201BE5 		ldr	r2, [fp, #-12]
 1280 09c0 AC319FE5 		ldr	r3, .L65+12
 1281 09c4 030052E1 		cmp	r2, r3
 1282 09c8 0100009A 		bls	.L59
 480:../sdrx3.c    **** 						value = CY_FX_PWM_PERIOD -1;
 1283              		.loc 1 480 0
 1284 09cc A0319FE5 		ldr	r3, .L65+12
 1285 09d0 0C300BE5 		str	r3, [fp, #-12]
 1286              	.L59:
 481:../sdrx3.c    **** 					apiRetStatus = ConfGPIOPWM(24,value);
 1287              		.loc 1 481 0
 1288 09d4 1800A0E3 		mov	r0, #24
 1289 09d8 0C101BE5 		ldr	r1, [fp, #-12]
 1290 09dc FEFFFFEB 		bl	ConfGPIOPWM
 1291 09e0 10000BE5 		str	r0, [fp, #-16]
 482:../sdrx3.c    **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 1292              		.loc 1 482 0
 1293 09e4 10301BE5 		ldr	r3, [fp, #-16]
 1294 09e8 000053E3 		cmp	r3, #0
 1295 09ec 0800000A 		beq	.L58
 483:../sdrx3.c    **** 					{
 484:../sdrx3.c    **** 						isHandled = CyFalse;
 1296              		.loc 1 484 0
 1297 09f0 0030A0E3 		mov	r3, #0
 1298 09f4 14300BE5 		str	r3, [fp, #-20]
 485:../sdrx3.c    **** 						CyU3PDebugPrint (4, "\n CY_FX_RQT_GPIO_PWM failed, error code = %d\n",
 1299              		.loc 1 485 0
 1300 09f8 0400A0E3 		mov	r0, #4
 1301 09fc 74119FE5 		ldr	r1, .L65+16
 1302 0a00 10201BE5 		ldr	r2, [fp, #-16]
 1303 0a04 FEFFFFEB 		bl	CyU3PDebugPrint
 486:../sdrx3.c    **** 								apiRetStatus);
 487:../sdrx3.c    **** 						SDR_ErrorHandler(apiRetStatus);
 1304              		.loc 1 487 0
 1305 0a08 10001BE5 		ldr	r0, [fp, #-16]
 1306 0a0c FEFFFFEB 		bl	SDR_ErrorHandler
 488:../sdrx3.c    **** 					}
 489:../sdrx3.c    **** 				}
 490:../sdrx3.c    **** 				break;
 1307              		.loc 1 490 0
 1308 0a10 4E0000EA 		b	.L56
 1309              	.L58:
 1310 0a14 4D0000EA 		b	.L56
 1311              	.L52:
 491:../sdrx3.c    **** 
 492:../sdrx3.c    **** 			case CY_FX_RQT_I2C_WRITE:
 493:../sdrx3.c    **** 				if(CyU3PUsbGetEP0Data(wLength, glEp0Buffer, NULL)== CY_U3P_SUCCESS)
 1312              		.loc 1 493 0
 1313 0a18 B6305BE1 		ldrh	r3, [fp, #-6]
 1314 0a1c 0300A0E1 		mov	r0, r3
 1315 0a20 44119FE5 		ldr	r1, .L65+4
 1316 0a24 0020A0E3 		mov	r2, #0
 1317 0a28 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1318 0a2c 0030A0E1 		mov	r3, r0
 1319 0a30 000053E3 		cmp	r3, #0
 1320 0a34 1700001A 		bne	.L60
 494:../sdrx3.c    **** 				{
 495:../sdrx3.c    **** 					apiRetStatus = CyFxUsbI2cTransfer ( wIndex, wValue, wLength, glEp0Buffer, CyFalse);
 1321              		.loc 1 495 0
 1322 0a38 BC315BE1 		ldrh	r3, [fp, #-28]	@ movhi
 1323 0a3c FF1003E2 		and	r1, r3, #255
 1324 0a40 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 1325 0a44 FF2003E2 		and	r2, r3, #255
 1326 0a48 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1327 0a4c FF3003E2 		and	r3, r3, #255
 1328 0a50 0000A0E3 		mov	r0, #0
 1329 0a54 00008DE5 		str	r0, [sp]
 1330 0a58 0100A0E1 		mov	r0, r1
 1331 0a5c 0210A0E1 		mov	r1, r2
 1332 0a60 0320A0E1 		mov	r2, r3
 1333 0a64 00319FE5 		ldr	r3, .L65+4
 1334 0a68 FEFFFFEB 		bl	CyFxUsbI2cTransfer
 1335 0a6c 10000BE5 		str	r0, [fp, #-16]
 496:../sdrx3.c    **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 1336              		.loc 1 496 0
 1337 0a70 10301BE5 		ldr	r3, [fp, #-16]
 1338 0a74 000053E3 		cmp	r3, #0
 1339 0a78 0600000A 		beq	.L60
 497:../sdrx3.c    **** 					{
 498:../sdrx3.c    **** 						isHandled = CyFalse;
 1340              		.loc 1 498 0
 1341 0a7c 0030A0E3 		mov	r3, #0
 1342 0a80 14300BE5 		str	r3, [fp, #-20]
 499:../sdrx3.c    **** 						CyU3PDebugPrint (4, "\n\rCY_FX_RQT_I2C_WRITE failed, error code = 0x%X\n",apiRetStatus);
 1343              		.loc 1 499 0
 1344 0a84 0400A0E3 		mov	r0, #4
 1345 0a88 EC109FE5 		ldr	r1, .L65+20
 1346 0a8c 10201BE5 		ldr	r2, [fp, #-16]
 1347 0a90 FEFFFFEB 		bl	CyU3PDebugPrint
 500:../sdrx3.c    **** 					}
 501:../sdrx3.c    **** 				}
 502:../sdrx3.c    **** 				break;
 1348              		.loc 1 502 0
 1349 0a94 2D0000EA 		b	.L56
 1350              	.L60:
 1351 0a98 2C0000EA 		b	.L56
 1352              	.L53:
 503:../sdrx3.c    **** 
 504:../sdrx3.c    **** 			case CY_FX_RQT_I2C_READ:
 505:../sdrx3.c    **** 				CyU3PMemSet (glEp0Buffer, 0, sizeof (glEp0Buffer));
 1353              		.loc 1 505 0
 1354 0a9c C8009FE5 		ldr	r0, .L65+4
 1355 0aa0 0010A0E3 		mov	r1, #0
 1356 0aa4 2020A0E3 		mov	r2, #32
 1357 0aa8 FEFFFFEB 		bl	CyU3PMemSet
 506:../sdrx3.c    **** 				if (wLength >= 64) wLength = 64;
 1358              		.loc 1 506 0
 1359 0aac B6305BE1 		ldrh	r3, [fp, #-6]
 1360 0ab0 3F0053E3 		cmp	r3, #63
 1361 0ab4 0100009A 		bls	.L61
 1362              		.loc 1 506 0 is_stmt 0 discriminator 1
 1363 0ab8 4030A0E3 		mov	r3, #64
 1364 0abc B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1365              	.L61:
 507:../sdrx3.c    **** 				apiRetStatus = CyFxUsbI2cTransfer (wIndex, wValue, wLength,glEp0Buffer, CyTrue);
 1366              		.loc 1 507 0 is_stmt 1
 1367 0ac0 BC315BE1 		ldrh	r3, [fp, #-28]	@ movhi
 1368 0ac4 FF1003E2 		and	r1, r3, #255
 1369 0ac8 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 1370 0acc FF2003E2 		and	r2, r3, #255
 1371 0ad0 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1372 0ad4 FF3003E2 		and	r3, r3, #255
 1373 0ad8 0100A0E3 		mov	r0, #1
 1374 0adc 00008DE5 		str	r0, [sp]
 1375 0ae0 0100A0E1 		mov	r0, r1
 1376 0ae4 0210A0E1 		mov	r1, r2
 1377 0ae8 0320A0E1 		mov	r2, r3
 1378 0aec 78309FE5 		ldr	r3, .L65+4
 1379 0af0 FEFFFFEB 		bl	CyFxUsbI2cTransfer
 1380 0af4 10000BE5 		str	r0, [fp, #-16]
 508:../sdrx3.c    **** 				if (apiRetStatus == CY_U3P_SUCCESS)
 1381              		.loc 1 508 0
 1382 0af8 10301BE5 		ldr	r3, [fp, #-16]
 1383 0afc 000053E3 		cmp	r3, #0
 1384 0b00 0400001A 		bne	.L62
 509:../sdrx3.c    **** 				{
 510:../sdrx3.c    **** 					apiRetStatus = CyU3PUsbSendEP0Data(wLength, glEp0Buffer);
 1385              		.loc 1 510 0
 1386 0b04 B6305BE1 		ldrh	r3, [fp, #-6]
 1387 0b08 0300A0E1 		mov	r0, r3
 1388 0b0c 58109FE5 		ldr	r1, .L65+4
 1389 0b10 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1390 0b14 10000BE5 		str	r0, [fp, #-16]
 1391              	.L62:
 511:../sdrx3.c    **** 				}
 512:../sdrx3.c    **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 1392              		.loc 1 512 0
 1393 0b18 10301BE5 		ldr	r3, [fp, #-16]
 1394 0b1c 000053E3 		cmp	r3, #0
 1395 0b20 0600000A 		beq	.L63
 513:../sdrx3.c    **** 				{
 514:../sdrx3.c    **** 					isHandled = CyFalse;
 1396              		.loc 1 514 0
 1397 0b24 0030A0E3 		mov	r3, #0
 1398 0b28 14300BE5 		str	r3, [fp, #-20]
 515:../sdrx3.c    **** 					CyU3PDebugPrint (4, "\n\rCY_FX_RQT_I2C_READ failed, error code = 0x%X\n",apiRetStatus);
 1399              		.loc 1 515 0
 1400 0b2c 0400A0E3 		mov	r0, #4
 1401 0b30 48109FE5 		ldr	r1, .L65+24
 1402 0b34 10201BE5 		ldr	r2, [fp, #-16]
 1403 0b38 FEFFFFEB 		bl	CyU3PDebugPrint
 516:../sdrx3.c    **** 				}
 517:../sdrx3.c    **** 				break;
 1404              		.loc 1 517 0
 1405 0b3c 030000EA 		b	.L56
 1406              	.L63:
 1407 0b40 020000EA 		b	.L56
 1408              	.L49:
 518:../sdrx3.c    **** 
 519:../sdrx3.c    **** 			default:
 520:../sdrx3.c    **** 				/* This is unknown request. */
 521:../sdrx3.c    **** 				isHandled = CyFalse;
 1409              		.loc 1 521 0
 1410 0b44 0030A0E3 		mov	r3, #0
 1411 0b48 14300BE5 		str	r3, [fp, #-20]
 522:../sdrx3.c    **** 				break;
 1412              		.loc 1 522 0
 1413 0b4c 0000A0E1 		mov	r0, r0	@ nop
 1414              	.L56:
 523:../sdrx3.c    **** 		}
 524:../sdrx3.c    **** 		return isHandled;
 1415              		.loc 1 524 0
 1416 0b50 14301BE5 		ldr	r3, [fp, #-20]
 1417 0b54 000000EA 		b	.L64
 1418              	.L48:
 525:../sdrx3.c    **** 	}
 526:../sdrx3.c    **** 	/* Fast enumeration is used. Only class, vendor and unknown requests
 527:../sdrx3.c    **** 	 * are received by this function. These are not handled in this
 528:../sdrx3.c    **** 	 * application. Hence return CyFalse. */
 529:../sdrx3.c    **** 	return CyFalse;
 1419              		.loc 1 529 0
 1420 0b58 0030A0E3 		mov	r3, #0
 1421              	.L64:
 530:../sdrx3.c    **** }
 1422              		.loc 1 530 0
 1423 0b5c 0300A0E1 		mov	r0, r3
 1424 0b60 04D04BE2 		sub	sp, fp, #4
 1425              		@ sp needed
 1426 0b64 0088BDE8 		ldmfd	sp!, {fp, pc}
 1427              	.L66:
 1428              		.align	2
 1429              	.L65:
 1430 0b68 00000000 		.word	glFirmwareID
 1431 0b6c 00000000 		.word	glEp0Buffer
 1432 0b70 01000000 		.word	glEp0Buffer+1
 1433 0b74 7E130300 		.word	201598
 1434 0b78 10010000 		.word	.LC5
 1435 0b7c 40010000 		.word	.LC6
 1436 0b80 74010000 		.word	.LC7
 1437              		.cfi_endproc
 1438              	.LFE8:
 1440              		.section	.rodata
 1441              		.align	2
 1442              	.LC8:
 1443 01a4 0A0D2047 		.ascii	"\012\015 GPIF overflow INT received\012\000"
 1443      50494620 
 1443      6F766572 
 1443      666C6F77 
 1443      20494E54 
 1444              		.text
 1445              		.align	2
 1446              		.global	SDR_ApplnGPIFEventCB
 1448              	SDR_ApplnGPIFEventCB:
 1449              	.LFB9:
 531:../sdrx3.c    **** /* This is a callback function to handle gpif events */
 532:../sdrx3.c    **** void
 533:../sdrx3.c    **** SDR_ApplnGPIFEventCB (
 534:../sdrx3.c    **** 		CyU3PGpifEventType event,               /* Event type that is being notified. */
 535:../sdrx3.c    **** 		uint8_t            currentState         /* Current state of the State Machine. */
 536:../sdrx3.c    **** )
 537:../sdrx3.c    **** {
 1450              		.loc 1 537 0
 1451              		.cfi_startproc
 1452              		@ args = 0, pretend = 0, frame = 8
 1453              		@ frame_needed = 1, uses_anonymous_args = 0
 1454 0b84 00482DE9 		stmfd	sp!, {fp, lr}
 1455              	.LCFI18:
 1456              		.cfi_def_cfa_offset 8
 1457              		.cfi_offset 11, -8
 1458              		.cfi_offset 14, -4
 1459 0b88 04B08DE2 		add	fp, sp, #4
 1460              	.LCFI19:
 1461              		.cfi_def_cfa 11, 4
 1462 0b8c 08D04DE2 		sub	sp, sp, #8
 1463 0b90 0020A0E1 		mov	r2, r0
 1464 0b94 0130A0E1 		mov	r3, r1
 1465 0b98 05204BE5 		strb	r2, [fp, #-5]
 1466 0b9c 06304BE5 		strb	r3, [fp, #-6]
 538:../sdrx3.c    **** 	switch (event)
 1467              		.loc 1 538 0
 1468 0ba0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1469 0ba4 010053E3 		cmp	r3, #1
 1470 0ba8 0000000A 		beq	.L69
 539:../sdrx3.c    **** 	{
 540:../sdrx3.c    **** 	case CYU3P_GPIF_EVT_SM_INTERRUPT:
 541:../sdrx3.c    **** 	{
 542:../sdrx3.c    **** 		CyU3PDebugPrint (4, "\n\r GPIF overflow INT received\n");
 543:../sdrx3.c    **** 
 544:../sdrx3.c    **** 	}
 545:../sdrx3.c    **** 	break;
 546:../sdrx3.c    **** 
 547:../sdrx3.c    **** 	default:
 548:../sdrx3.c    **** 		break;
 1471              		.loc 1 548 0
 1472 0bac 030000EA 		b	.L67
 1473              	.L69:
 542:../sdrx3.c    **** 
 1474              		.loc 1 542 0
 1475 0bb0 0400A0E3 		mov	r0, #4
 1476 0bb4 0C109FE5 		ldr	r1, .L71
 1477 0bb8 FEFFFFEB 		bl	CyU3PDebugPrint
 545:../sdrx3.c    **** 
 1478              		.loc 1 545 0
 1479 0bbc 0000A0E1 		mov	r0, r0	@ nop
 1480              	.L67:
 549:../sdrx3.c    **** 	}
 550:../sdrx3.c    **** }
 1481              		.loc 1 550 0
 1482 0bc0 04D04BE2 		sub	sp, fp, #4
 1483              		@ sp needed
 1484 0bc4 0088BDE8 		ldmfd	sp!, {fp, pc}
 1485              	.L72:
 1486              		.align	2
 1487              	.L71:
 1488 0bc8 A4010000 		.word	.LC8
 1489              		.cfi_endproc
 1490              	.LFE9:
 1492              		.align	2
 1493              		.global	SDR_ApplnUSBEventCB
 1495              	SDR_ApplnUSBEventCB:
 1496              	.LFB10:
 551:../sdrx3.c    **** 
 552:../sdrx3.c    **** /* This is the callback function to handle the USB events. */
 553:../sdrx3.c    **** void
 554:../sdrx3.c    **** SDR_ApplnUSBEventCB (
 555:../sdrx3.c    **** 		CyU3PUsbEventType_t evtype, /* Event type */
 556:../sdrx3.c    **** 		uint16_t            evdata  /* Event data */
 557:../sdrx3.c    **** )
 558:../sdrx3.c    **** {
 1497              		.loc 1 558 0
 1498              		.cfi_startproc
 1499              		@ args = 0, pretend = 0, frame = 8
 1500              		@ frame_needed = 1, uses_anonymous_args = 0
 1501 0bcc 00482DE9 		stmfd	sp!, {fp, lr}
 1502              	.LCFI20:
 1503              		.cfi_def_cfa_offset 8
 1504              		.cfi_offset 11, -8
 1505              		.cfi_offset 14, -4
 1506 0bd0 04B08DE2 		add	fp, sp, #4
 1507              	.LCFI21:
 1508              		.cfi_def_cfa 11, 4
 1509 0bd4 08D04DE2 		sub	sp, sp, #8
 1510 0bd8 0020A0E1 		mov	r2, r0
 1511 0bdc 0130A0E1 		mov	r3, r1
 1512 0be0 05204BE5 		strb	r2, [fp, #-5]
 1513 0be4 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 559:../sdrx3.c    **** 	switch (evtype)
 1514              		.loc 1 559 0
 1515 0be8 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1516 0bec 040053E3 		cmp	r3, #4
 1517 0bf0 0B00000A 		beq	.L75
 1518 0bf4 050053E3 		cmp	r3, #5
 1519 0bf8 0200000A 		beq	.L76
 1520 0bfc 010053E3 		cmp	r3, #1
 1521 0c00 0700000A 		beq	.L75
 560:../sdrx3.c    **** 	{
 561:../sdrx3.c    **** 	case CY_U3P_USB_EVENT_SETCONF:
 562:../sdrx3.c    **** 		/* If the application is already active
 563:../sdrx3.c    **** 		 * stop it before re-enabling. */
 564:../sdrx3.c    **** 		if (glIsApplnActive)
 565:../sdrx3.c    **** 		{
 566:../sdrx3.c    **** 			SDR_ApplnStop ();
 567:../sdrx3.c    **** 		}
 568:../sdrx3.c    **** 		/* Start the source sink function. */
 569:../sdrx3.c    **** 		SDR_ApplnStart ();
 570:../sdrx3.c    **** 		break;
 571:../sdrx3.c    **** 
 572:../sdrx3.c    **** 	case CY_U3P_USB_EVENT_RESET:
 573:../sdrx3.c    **** 	case CY_U3P_USB_EVENT_DISCONNECT:
 574:../sdrx3.c    **** 		/* Stop the source sink function. */
 575:../sdrx3.c    **** 		if (glIsApplnActive)
 576:../sdrx3.c    **** 		{
 577:../sdrx3.c    **** 			SDR_ApplnStop ();
 578:../sdrx3.c    **** 		}
 579:../sdrx3.c    **** 		break;
 580:../sdrx3.c    **** 
 581:../sdrx3.c    **** 	default:
 582:../sdrx3.c    **** 		break;
 1522              		.loc 1 582 0
 1523 0c04 0D0000EA 		b	.L73
 1524              	.L76:
 564:../sdrx3.c    **** 		{
 1525              		.loc 1 564 0
 1526 0c08 38309FE5 		ldr	r3, .L81
 1527 0c0c 003093E5 		ldr	r3, [r3]
 1528 0c10 000053E3 		cmp	r3, #0
 1529 0c14 0000000A 		beq	.L77
 566:../sdrx3.c    **** 		}
 1530              		.loc 1 566 0
 1531 0c18 FEFFFFEB 		bl	SDR_ApplnStop
 1532              	.L77:
 569:../sdrx3.c    **** 		break;
 1533              		.loc 1 569 0
 1534 0c1c FEFFFFEB 		bl	SDR_ApplnStart
 570:../sdrx3.c    **** 
 1535              		.loc 1 570 0
 1536 0c20 060000EA 		b	.L73
 1537              	.L75:
 575:../sdrx3.c    **** 		{
 1538              		.loc 1 575 0
 1539 0c24 1C309FE5 		ldr	r3, .L81
 1540 0c28 003093E5 		ldr	r3, [r3]
 1541 0c2c 000053E3 		cmp	r3, #0
 1542 0c30 0100000A 		beq	.L79
 577:../sdrx3.c    **** 		}
 1543              		.loc 1 577 0
 1544 0c34 FEFFFFEB 		bl	SDR_ApplnStop
 579:../sdrx3.c    **** 
 1545              		.loc 1 579 0
 1546 0c38 FFFFFFEA 		b	.L80
 1547              	.L79:
 1548              	.L80:
 1549 0c3c 0000A0E1 		mov	r0, r0	@ nop
 1550              	.L73:
 583:../sdrx3.c    **** 	}
 584:../sdrx3.c    **** }
 1551              		.loc 1 584 0
 1552 0c40 04D04BE2 		sub	sp, fp, #4
 1553              		@ sp needed
 1554 0c44 0088BDE8 		ldmfd	sp!, {fp, pc}
 1555              	.L82:
 1556              		.align	2
 1557              	.L81:
 1558 0c48 00000000 		.word	glIsApplnActive
 1559              		.cfi_endproc
 1560              	.LFE10:
 1562              		.section	.rodata
 1563 01c3 00       		.align	2
 1564              	.LC9:
 1565 01c4 0A0D4379 		.ascii	"\012\015CyU3PGpifSMStart failed, Error Code = %d\012"
 1565      55335047 
 1565      70696653 
 1565      4D537461 
 1565      72742066 
 1566 01ef 00       		.ascii	"\000"
 1567              		.text
 1568              		.align	2
 1569              		.global	SDR_StartGpif
 1571              	SDR_StartGpif:
 1572              	.LFB11:
 585:../sdrx3.c    **** 
 586:../sdrx3.c    **** void SDR_StartGpif(void)
 587:../sdrx3.c    **** {
 1573              		.loc 1 587 0
 1574              		.cfi_startproc
 1575              		@ args = 0, pretend = 0, frame = 8
 1576              		@ frame_needed = 1, uses_anonymous_args = 0
 1577 0c4c 00482DE9 		stmfd	sp!, {fp, lr}
 1578              	.LCFI22:
 1579              		.cfi_def_cfa_offset 8
 1580              		.cfi_offset 11, -8
 1581              		.cfi_offset 14, -4
 1582 0c50 04B08DE2 		add	fp, sp, #4
 1583              	.LCFI23:
 1584              		.cfi_def_cfa 11, 4
 1585 0c54 08D04DE2 		sub	sp, sp, #8
 588:../sdrx3.c    **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 1586              		.loc 1 588 0
 1587 0c58 0030A0E3 		mov	r3, #0
 1588 0c5c 08300BE5 		str	r3, [fp, #-8]
 589:../sdrx3.c    **** /* Start the state machine. */
 590:../sdrx3.c    **** 	    	apiRetStatus = CyU3PGpifSMStart (RESET, ALPHA_RESET);
 1589              		.loc 1 590 0
 1590 0c60 0000A0E3 		mov	r0, #0
 1591 0c64 1410A0E3 		mov	r1, #20
 1592 0c68 FEFFFFEB 		bl	CyU3PGpifSMStart
 1593 0c6c 08000BE5 		str	r0, [fp, #-8]
 591:../sdrx3.c    **** 	    	if (apiRetStatus != CY_U3P_SUCCESS)
 1594              		.loc 1 591 0
 1595 0c70 08301BE5 		ldr	r3, [fp, #-8]
 1596 0c74 000053E3 		cmp	r3, #0
 1597 0c78 0300000A 		beq	.L83
 592:../sdrx3.c    **** 	    	{
 593:../sdrx3.c    **** 	    		CyU3PDebugPrint (4, "\n\rCyU3PGpifSMStart failed, Error Code = %d\n",apiRetStatus);
 1598              		.loc 1 593 0
 1599 0c7c 0400A0E3 		mov	r0, #4
 1600 0c80 0C109FE5 		ldr	r1, .L85
 1601 0c84 08201BE5 		ldr	r2, [fp, #-8]
 1602 0c88 FEFFFFEB 		bl	CyU3PDebugPrint
 1603              	.L83:
 594:../sdrx3.c    **** 
 595:../sdrx3.c    **** 	    	}
 596:../sdrx3.c    **** }
 1604              		.loc 1 596 0
 1605 0c8c 04D04BE2 		sub	sp, fp, #4
 1606              		@ sp needed
 1607 0c90 0088BDE8 		ldmfd	sp!, {fp, pc}
 1608              	.L86:
 1609              		.align	2
 1610              	.L85:
 1611 0c94 C4010000 		.word	.LC9
 1612              		.cfi_endproc
 1613              	.LFE11:
 1615              		.section	.rodata
 1616              		.align	2
 1617              	.LC10:
 1618 01f0 502D706F 		.ascii	"P-port Initialization failed, Error Code = %d\012\000"
 1618      72742049 
 1618      6E697469 
 1618      616C697A 
 1618      6174696F 
 1619 021f 00       		.align	2
 1620              	.LC11:
 1621 0220 43795533 		.ascii	"CyU3PGpifLoad failed, Error Code = %d\012\000"
 1621      50477069 
 1621      664C6F61 
 1621      64206661 
 1621      696C6564 
 1622 0247 00       		.align	2
 1623              	.LC12:
 1624 0248 43795533 		.ascii	"CyU3PUsbStart failed to Start, Error code = %d\012\000"
 1624      50557362 
 1624      53746172 
 1624      74206661 
 1624      696C6564 
 1625              		.align	2
 1626              	.LC13:
 1627 0278 55534220 		.ascii	"USB set device descriptor failed, Error code = %d\012"
 1627      73657420 
 1627      64657669 
 1627      63652064 
 1627      65736372 
 1628 02aa 00       		.ascii	"\000"
 1629 02ab 00       		.align	2
 1630              	.LC14:
 1631 02ac 55534220 		.ascii	"USB set configuration descriptor failed, Error code"
 1631      73657420 
 1631      636F6E66 
 1631      69677572 
 1631      6174696F 
 1632 02df 203D2025 		.ascii	" = %d\012\000"
 1632      640A00
 1633 02e6 0000     		.align	2
 1634              	.LC15:
 1635 02e8 55534220 		.ascii	"USB set device qualifier descriptor failed, Error c"
 1635      73657420 
 1635      64657669 
 1635      63652071 
 1635      75616C69 
 1636 031b 6F646520 		.ascii	"ode = %d\012\000"
 1636      3D202564 
 1636      0A00
 1637 0325 000000   		.align	2
 1638              	.LC16:
 1639 0328 55534220 		.ascii	"USB Set Other Speed Descriptor failed, Error Code ="
 1639      53657420 
 1639      4F746865 
 1639      72205370 
 1639      65656420 
 1640 035b 2025640A 		.ascii	" %d\012\000"
 1640      00
 1641              		.align	2
 1642              	.LC17:
 1643 0360 55534220 		.ascii	"USB Set Configuration Descriptor failed, Error Code"
 1643      53657420 
 1643      436F6E66 
 1643      69677572 
 1643      6174696F 
 1644 0393 203D2025 		.ascii	" = %d\012\000"
 1644      640A00
 1645 039a 0000     		.align	2
 1646              	.LC18:
 1647 039c 55534220 		.ascii	"USB set string descriptor failed, Error code = %d\012"
 1647      73657420 
 1647      73747269 
 1647      6E672064 
 1647      65736372 
 1648 03ce 00       		.ascii	"\000"
 1649 03cf 00       		.align	2
 1650              	.LC19:
 1651 03d0 55534220 		.ascii	"USB Connect failed, Error code = %d\012\000"
 1651      436F6E6E 
 1651      65637420 
 1651      6661696C 
 1651      65642C20 
 1652              		.text
 1653              		.align	2
 1654              		.global	SDR_ApplnInit
 1656              	SDR_ApplnInit:
 1657              	.LFB12:
 597:../sdrx3.c    **** 
 598:../sdrx3.c    **** /* This function initializes the USB Module, sets the enumeration descriptors.
 599:../sdrx3.c    ****  * This function does not start the bulk streaming and this is done only when
 600:../sdrx3.c    ****  * SET_CONF event is received. */
 601:../sdrx3.c    **** void
 602:../sdrx3.c    **** SDR_ApplnInit (void)
 603:../sdrx3.c    **** {
 1658              		.loc 1 603 0
 1659              		.cfi_startproc
 1660              		@ args = 0, pretend = 0, frame = 24
 1661              		@ frame_needed = 1, uses_anonymous_args = 0
 1662 0c98 00482DE9 		stmfd	sp!, {fp, lr}
 1663              	.LCFI24:
 1664              		.cfi_def_cfa_offset 8
 1665              		.cfi_offset 11, -8
 1666              		.cfi_offset 14, -4
 1667 0c9c 04B08DE2 		add	fp, sp, #4
 1668              	.LCFI25:
 1669              		.cfi_def_cfa 11, 4
 1670 0ca0 18D04DE2 		sub	sp, sp, #24
 604:../sdrx3.c    **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 1671              		.loc 1 604 0
 1672 0ca4 0030A0E3 		mov	r3, #0
 1673 0ca8 08300BE5 		str	r3, [fp, #-8]
 605:../sdrx3.c    **** 	/**************************************GPIF****************************************************/
 606:../sdrx3.c    **** 	CyU3PPibClock_t pibClock;
 607:../sdrx3.c    **** 
 608:../sdrx3.c    **** 	/* Initialize the p-port block. */
 609:../sdrx3.c    **** 	pibClock.clkDiv = 2;
 1674              		.loc 1 609 0
 1675 0cac 0230A0E3 		mov	r3, #2
 1676 0cb0 B8314BE1 		strh	r3, [fp, #-24]	@ movhi
 610:../sdrx3.c    **** 	pibClock.clkSrc = CY_U3P_SYS_CLK;
 1677              		.loc 1 610 0
 1678 0cb4 0330A0E3 		mov	r3, #3
 1679 0cb8 0C304BE5 		strb	r3, [fp, #-12]
 611:../sdrx3.c    **** 	pibClock.isHalfDiv = CyFalse;
 1680              		.loc 1 611 0
 1681 0cbc 0030A0E3 		mov	r3, #0
 1682 0cc0 14300BE5 		str	r3, [fp, #-20]
 612:../sdrx3.c    **** 	/* Disable DLL for sync GPIF */
 613:../sdrx3.c    **** 	pibClock.isDllEnable = CyFalse;
 1683              		.loc 1 613 0
 1684 0cc4 0030A0E3 		mov	r3, #0
 1685 0cc8 10300BE5 		str	r3, [fp, #-16]
 614:../sdrx3.c    **** 	apiRetStatus = CyU3PPibInit(CyTrue, &pibClock);
 1686              		.loc 1 614 0
 1687 0ccc 18304BE2 		sub	r3, fp, #24
 1688 0cd0 0100A0E3 		mov	r0, #1
 1689 0cd4 0310A0E1 		mov	r1, r3
 1690 0cd8 FEFFFFEB 		bl	CyU3PPibInit
 1691 0cdc 08000BE5 		str	r0, [fp, #-8]
 615:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1692              		.loc 1 615 0
 1693 0ce0 08301BE5 		ldr	r3, [fp, #-8]
 1694 0ce4 000053E3 		cmp	r3, #0
 1695 0ce8 0500000A 		beq	.L88
 616:../sdrx3.c    **** 	{
 617:../sdrx3.c    **** 		CyU3PDebugPrint (4, "P-port Initialization failed, Error Code = %d\n",apiRetStatus);
 1696              		.loc 1 617 0
 1697 0cec 0400A0E3 		mov	r0, #4
 1698 0cf0 F0129FE5 		ldr	r1, .L102
 1699 0cf4 08201BE5 		ldr	r2, [fp, #-8]
 1700 0cf8 FEFFFFEB 		bl	CyU3PDebugPrint
 618:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1701              		.loc 1 618 0
 1702 0cfc 08001BE5 		ldr	r0, [fp, #-8]
 1703 0d00 FEFFFFEB 		bl	SDR_ErrorHandler
 1704              	.L88:
 619:../sdrx3.c    **** 	}
 620:../sdrx3.c    **** 
 621:../sdrx3.c    **** 	/* Load the GPIF configuration for Slave FIFO sync mode. */
 622:../sdrx3.c    **** 	apiRetStatus = CyU3PGpifLoad (&CyFxGpifConfig);
 1705              		.loc 1 622 0
 1706 0d04 E0029FE5 		ldr	r0, .L102+4
 1707 0d08 FEFFFFEB 		bl	CyU3PGpifLoad
 1708 0d0c 08000BE5 		str	r0, [fp, #-8]
 623:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1709              		.loc 1 623 0
 1710 0d10 08301BE5 		ldr	r3, [fp, #-8]
 1711 0d14 000053E3 		cmp	r3, #0
 1712 0d18 0500000A 		beq	.L89
 624:../sdrx3.c    **** 	{
 625:../sdrx3.c    **** 		CyU3PDebugPrint (4, "CyU3PGpifLoad failed, Error Code = %d\n",apiRetStatus);
 1713              		.loc 1 625 0
 1714 0d1c 0400A0E3 		mov	r0, #4
 1715 0d20 C8129FE5 		ldr	r1, .L102+8
 1716 0d24 08201BE5 		ldr	r2, [fp, #-8]
 1717 0d28 FEFFFFEB 		bl	CyU3PDebugPrint
 626:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1718              		.loc 1 626 0
 1719 0d2c 08001BE5 		ldr	r0, [fp, #-8]
 1720 0d30 FEFFFFEB 		bl	SDR_ErrorHandler
 1721              	.L89:
 627:../sdrx3.c    **** 	}
 628:../sdrx3.c    **** 
 629:../sdrx3.c    **** 
 630:../sdrx3.c    **** 	CyU3PGpifRegisterCallback(SDR_ApplnGPIFEventCB);
 1722              		.loc 1 630 0
 1723 0d34 B8029FE5 		ldr	r0, .L102+12
 1724 0d38 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 631:../sdrx3.c    **** 
 632:../sdrx3.c    **** 	/**********************************************************************************************/
 633:../sdrx3.c    **** 	/* Start the USB functionality. */
 634:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbStart();
 1725              		.loc 1 634 0
 1726 0d3c FEFFFFEB 		bl	CyU3PUsbStart
 1727 0d40 08000BE5 		str	r0, [fp, #-8]
 635:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1728              		.loc 1 635 0
 1729 0d44 08301BE5 		ldr	r3, [fp, #-8]
 1730 0d48 000053E3 		cmp	r3, #0
 1731 0d4c 0500000A 		beq	.L90
 636:../sdrx3.c    **** 	{
 637:../sdrx3.c    **** 		CyU3PDebugPrint (4, "CyU3PUsbStart failed to Start, Error code = %d\n", apiRetStatus);
 1732              		.loc 1 637 0
 1733 0d50 0400A0E3 		mov	r0, #4
 1734 0d54 9C129FE5 		ldr	r1, .L102+16
 1735 0d58 08201BE5 		ldr	r2, [fp, #-8]
 1736 0d5c FEFFFFEB 		bl	CyU3PDebugPrint
 638:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1737              		.loc 1 638 0
 1738 0d60 08001BE5 		ldr	r0, [fp, #-8]
 1739 0d64 FEFFFFEB 		bl	SDR_ErrorHandler
 1740              	.L90:
 639:../sdrx3.c    **** 	}
 640:../sdrx3.c    **** 
 641:../sdrx3.c    **** 	/* The fast enumeration is the easiest way to setup a USB connection,
 642:../sdrx3.c    **** 	 * where all enumeration phase is handled by the library. Only the
 643:../sdrx3.c    **** 	 * class / vendor requests need to be handled by the application. */
 644:../sdrx3.c    **** 	CyU3PUsbRegisterSetupCallback(SDR_ApplnUSBSetupCB, CyTrue);
 1741              		.loc 1 644 0
 1742 0d68 8C029FE5 		ldr	r0, .L102+20
 1743 0d6c 0110A0E3 		mov	r1, #1
 1744 0d70 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 645:../sdrx3.c    **** 
 646:../sdrx3.c    **** 	/* Setup the callback to handle the USB events. */
 647:../sdrx3.c    **** 	CyU3PUsbRegisterEventCallback(SDR_ApplnUSBEventCB);
 1745              		.loc 1 647 0
 1746 0d74 84029FE5 		ldr	r0, .L102+24
 1747 0d78 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 648:../sdrx3.c    **** 
 649:../sdrx3.c    **** 	/* Set the USB Enumeration descriptors */
 650:../sdrx3.c    **** 
 651:../sdrx3.c    **** 	/* Super speed device descriptor. */
 652:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, (int) NULL, (uint8_t *)CyFxUSB30Dev
 1748              		.loc 1 652 0
 1749 0d7c 0000A0E3 		mov	r0, #0
 1750 0d80 0010A0E3 		mov	r1, #0
 1751 0d84 78229FE5 		ldr	r2, .L102+28
 1752 0d88 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1753 0d8c 08000BE5 		str	r0, [fp, #-8]
 653:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1754              		.loc 1 653 0
 1755 0d90 08301BE5 		ldr	r3, [fp, #-8]
 1756 0d94 000053E3 		cmp	r3, #0
 1757 0d98 0500000A 		beq	.L91
 654:../sdrx3.c    **** 	{
 655:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", apiRetStatus);
 1758              		.loc 1 655 0
 1759 0d9c 0400A0E3 		mov	r0, #4
 1760 0da0 60129FE5 		ldr	r1, .L102+32
 1761 0da4 08201BE5 		ldr	r2, [fp, #-8]
 1762 0da8 FEFFFFEB 		bl	CyU3PDebugPrint
 656:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1763              		.loc 1 656 0
 1764 0dac 08001BE5 		ldr	r0, [fp, #-8]
 1765 0db0 FEFFFFEB 		bl	SDR_ErrorHandler
 1766              	.L91:
 657:../sdrx3.c    **** 	}
 658:../sdrx3.c    **** 
 659:../sdrx3.c    **** 	/* High speed device descriptor. */
 660:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR,(int) NULL, (uint8_t *)CyFxUSB20Devi
 1767              		.loc 1 660 0
 1768 0db4 0100A0E3 		mov	r0, #1
 1769 0db8 0010A0E3 		mov	r1, #0
 1770 0dbc 48229FE5 		ldr	r2, .L102+36
 1771 0dc0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1772 0dc4 08000BE5 		str	r0, [fp, #-8]
 661:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1773              		.loc 1 661 0
 1774 0dc8 08301BE5 		ldr	r3, [fp, #-8]
 1775 0dcc 000053E3 		cmp	r3, #0
 1776 0dd0 0500000A 		beq	.L92
 662:../sdrx3.c    **** 	{
 663:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", apiRetStatus);
 1777              		.loc 1 663 0
 1778 0dd4 0400A0E3 		mov	r0, #4
 1779 0dd8 28129FE5 		ldr	r1, .L102+32
 1780 0ddc 08201BE5 		ldr	r2, [fp, #-8]
 1781 0de0 FEFFFFEB 		bl	CyU3PDebugPrint
 664:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1782              		.loc 1 664 0
 1783 0de4 08001BE5 		ldr	r0, [fp, #-8]
 1784 0de8 FEFFFFEB 		bl	SDR_ErrorHandler
 1785              	.L92:
 665:../sdrx3.c    **** 	}
 666:../sdrx3.c    **** 
 667:../sdrx3.c    **** 	/* BOS descriptor */
 668:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR,(int)NULL, (uint8_t *)CyFxUSBBOSDscr);
 1786              		.loc 1 668 0
 1787 0dec 0700A0E3 		mov	r0, #7
 1788 0df0 0010A0E3 		mov	r1, #0
 1789 0df4 14229FE5 		ldr	r2, .L102+40
 1790 0df8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1791 0dfc 08000BE5 		str	r0, [fp, #-8]
 669:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1792              		.loc 1 669 0
 1793 0e00 08301BE5 		ldr	r3, [fp, #-8]
 1794 0e04 000053E3 		cmp	r3, #0
 1795 0e08 0500000A 		beq	.L93
 670:../sdrx3.c    **** 	{
 671:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", apiRetStatus);
 1796              		.loc 1 671 0
 1797 0e0c 0400A0E3 		mov	r0, #4
 1798 0e10 FC119FE5 		ldr	r1, .L102+44
 1799 0e14 08201BE5 		ldr	r2, [fp, #-8]
 1800 0e18 FEFFFFEB 		bl	CyU3PDebugPrint
 672:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1801              		.loc 1 672 0
 1802 0e1c 08001BE5 		ldr	r0, [fp, #-8]
 1803 0e20 FEFFFFEB 		bl	SDR_ErrorHandler
 1804              	.L93:
 673:../sdrx3.c    **** 	}
 674:../sdrx3.c    **** 
 675:../sdrx3.c    **** 	/* Device qualifier descriptor */
 676:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR,(int) NULL, (uint8_t *)CyFxUSBDeviceQu
 1805              		.loc 1 676 0
 1806 0e24 0200A0E3 		mov	r0, #2
 1807 0e28 0010A0E3 		mov	r1, #0
 1808 0e2c E4219FE5 		ldr	r2, .L102+48
 1809 0e30 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1810 0e34 08000BE5 		str	r0, [fp, #-8]
 677:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1811              		.loc 1 677 0
 1812 0e38 08301BE5 		ldr	r3, [fp, #-8]
 1813 0e3c 000053E3 		cmp	r3, #0
 1814 0e40 0500000A 		beq	.L94
 678:../sdrx3.c    **** 	{
 679:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set device qualifier descriptor failed, Error code = %d\n", apiRetStatus
 1815              		.loc 1 679 0
 1816 0e44 0400A0E3 		mov	r0, #4
 1817 0e48 CC119FE5 		ldr	r1, .L102+52
 1818 0e4c 08201BE5 		ldr	r2, [fp, #-8]
 1819 0e50 FEFFFFEB 		bl	CyU3PDebugPrint
 680:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1820              		.loc 1 680 0
 1821 0e54 08001BE5 		ldr	r0, [fp, #-8]
 1822 0e58 FEFFFFEB 		bl	SDR_ErrorHandler
 1823              	.L94:
 681:../sdrx3.c    **** 	}
 682:../sdrx3.c    **** 
 683:../sdrx3.c    **** 	/* Super speed configuration descriptor */
 684:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR,(int) NULL, (uint8_t *)CyFxUSBSSConf
 1824              		.loc 1 684 0
 1825 0e5c 0600A0E3 		mov	r0, #6
 1826 0e60 0010A0E3 		mov	r1, #0
 1827 0e64 B4219FE5 		ldr	r2, .L102+56
 1828 0e68 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1829 0e6c 08000BE5 		str	r0, [fp, #-8]
 685:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1830              		.loc 1 685 0
 1831 0e70 08301BE5 		ldr	r3, [fp, #-8]
 1832 0e74 000053E3 		cmp	r3, #0
 1833 0e78 0500000A 		beq	.L95
 686:../sdrx3.c    **** 	{
 687:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", apiRetStatus);
 1834              		.loc 1 687 0
 1835 0e7c 0400A0E3 		mov	r0, #4
 1836 0e80 8C119FE5 		ldr	r1, .L102+44
 1837 0e84 08201BE5 		ldr	r2, [fp, #-8]
 1838 0e88 FEFFFFEB 		bl	CyU3PDebugPrint
 688:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1839              		.loc 1 688 0
 1840 0e8c 08001BE5 		ldr	r0, [fp, #-8]
 1841 0e90 FEFFFFEB 		bl	SDR_ErrorHandler
 1842              	.L95:
 689:../sdrx3.c    **** 	}
 690:../sdrx3.c    **** 
 691:../sdrx3.c    **** 	/* High speed configuration descriptor */
 692:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR,(int) NULL, (uint8_t *)CyFxUSBHSConf
 1843              		.loc 1 692 0
 1844 0e94 0400A0E3 		mov	r0, #4
 1845 0e98 0010A0E3 		mov	r1, #0
 1846 0e9c 80219FE5 		ldr	r2, .L102+60
 1847 0ea0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1848 0ea4 08000BE5 		str	r0, [fp, #-8]
 693:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1849              		.loc 1 693 0
 1850 0ea8 08301BE5 		ldr	r3, [fp, #-8]
 1851 0eac 000053E3 		cmp	r3, #0
 1852 0eb0 0500000A 		beq	.L96
 694:../sdrx3.c    **** 	{
 695:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB Set Other Speed Descriptor failed, Error Code = %d\n", apiRetStatus);
 1853              		.loc 1 695 0
 1854 0eb4 0400A0E3 		mov	r0, #4
 1855 0eb8 68119FE5 		ldr	r1, .L102+64
 1856 0ebc 08201BE5 		ldr	r2, [fp, #-8]
 1857 0ec0 FEFFFFEB 		bl	CyU3PDebugPrint
 696:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1858              		.loc 1 696 0
 1859 0ec4 08001BE5 		ldr	r0, [fp, #-8]
 1860 0ec8 FEFFFFEB 		bl	SDR_ErrorHandler
 1861              	.L96:
 697:../sdrx3.c    **** 	}
 698:../sdrx3.c    **** 
 699:../sdrx3.c    **** 	/* Full speed configuration descriptor */
 700:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR,(int) NULL, (uint8_t *)CyFxUSBFSConf
 1862              		.loc 1 700 0
 1863 0ecc 0300A0E3 		mov	r0, #3
 1864 0ed0 0010A0E3 		mov	r1, #0
 1865 0ed4 50219FE5 		ldr	r2, .L102+68
 1866 0ed8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1867 0edc 08000BE5 		str	r0, [fp, #-8]
 701:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1868              		.loc 1 701 0
 1869 0ee0 08301BE5 		ldr	r3, [fp, #-8]
 1870 0ee4 000053E3 		cmp	r3, #0
 1871 0ee8 0500000A 		beq	.L97
 702:../sdrx3.c    **** 	{
 703:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB Set Configuration Descriptor failed, Error Code = %d\n", apiRetStatus);
 1872              		.loc 1 703 0
 1873 0eec 0400A0E3 		mov	r0, #4
 1874 0ef0 38119FE5 		ldr	r1, .L102+72
 1875 0ef4 08201BE5 		ldr	r2, [fp, #-8]
 1876 0ef8 FEFFFFEB 		bl	CyU3PDebugPrint
 704:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1877              		.loc 1 704 0
 1878 0efc 08001BE5 		ldr	r0, [fp, #-8]
 1879 0f00 FEFFFFEB 		bl	SDR_ErrorHandler
 1880              	.L97:
 705:../sdrx3.c    **** 	}
 706:../sdrx3.c    **** 
 707:../sdrx3.c    **** 	/* String descriptor 0 */
 708:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr)
 1881              		.loc 1 708 0
 1882 0f04 0500A0E3 		mov	r0, #5
 1883 0f08 0010A0E3 		mov	r1, #0
 1884 0f0c 20219FE5 		ldr	r2, .L102+76
 1885 0f10 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1886 0f14 08000BE5 		str	r0, [fp, #-8]
 709:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1887              		.loc 1 709 0
 1888 0f18 08301BE5 		ldr	r3, [fp, #-8]
 1889 0f1c 000053E3 		cmp	r3, #0
 1890 0f20 0500000A 		beq	.L98
 710:../sdrx3.c    **** 	{
 711:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1891              		.loc 1 711 0
 1892 0f24 0400A0E3 		mov	r0, #4
 1893 0f28 08119FE5 		ldr	r1, .L102+80
 1894 0f2c 08201BE5 		ldr	r2, [fp, #-8]
 1895 0f30 FEFFFFEB 		bl	CyU3PDebugPrint
 712:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1896              		.loc 1 712 0
 1897 0f34 08001BE5 		ldr	r0, [fp, #-8]
 1898 0f38 FEFFFFEB 		bl	SDR_ErrorHandler
 1899              	.L98:
 713:../sdrx3.c    **** 	}
 714:../sdrx3.c    **** 
 715:../sdrx3.c    **** 	/* String descriptor 1 */
 716:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 1900              		.loc 1 716 0
 1901 0f3c 0500A0E3 		mov	r0, #5
 1902 0f40 0110A0E3 		mov	r1, #1
 1903 0f44 F0209FE5 		ldr	r2, .L102+84
 1904 0f48 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1905 0f4c 08000BE5 		str	r0, [fp, #-8]
 717:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1906              		.loc 1 717 0
 1907 0f50 08301BE5 		ldr	r3, [fp, #-8]
 1908 0f54 000053E3 		cmp	r3, #0
 1909 0f58 0500000A 		beq	.L99
 718:../sdrx3.c    **** 	{
 719:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1910              		.loc 1 719 0
 1911 0f5c 0400A0E3 		mov	r0, #4
 1912 0f60 D0109FE5 		ldr	r1, .L102+80
 1913 0f64 08201BE5 		ldr	r2, [fp, #-8]
 1914 0f68 FEFFFFEB 		bl	CyU3PDebugPrint
 720:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1915              		.loc 1 720 0
 1916 0f6c 08001BE5 		ldr	r0, [fp, #-8]
 1917 0f70 FEFFFFEB 		bl	SDR_ErrorHandler
 1918              	.L99:
 721:../sdrx3.c    **** 	}
 722:../sdrx3.c    **** 
 723:../sdrx3.c    **** 	/* String descriptor 2 */
 724:../sdrx3.c    **** 	apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 1919              		.loc 1 724 0
 1920 0f74 0500A0E3 		mov	r0, #5
 1921 0f78 0210A0E3 		mov	r1, #2
 1922 0f7c BC209FE5 		ldr	r2, .L102+88
 1923 0f80 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1924 0f84 08000BE5 		str	r0, [fp, #-8]
 725:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1925              		.loc 1 725 0
 1926 0f88 08301BE5 		ldr	r3, [fp, #-8]
 1927 0f8c 000053E3 		cmp	r3, #0
 1928 0f90 0500000A 		beq	.L100
 726:../sdrx3.c    **** 	{
 727:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1929              		.loc 1 727 0
 1930 0f94 0400A0E3 		mov	r0, #4
 1931 0f98 98109FE5 		ldr	r1, .L102+80
 1932 0f9c 08201BE5 		ldr	r2, [fp, #-8]
 1933 0fa0 FEFFFFEB 		bl	CyU3PDebugPrint
 728:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1934              		.loc 1 728 0
 1935 0fa4 08001BE5 		ldr	r0, [fp, #-8]
 1936 0fa8 FEFFFFEB 		bl	SDR_ErrorHandler
 1937              	.L100:
 729:../sdrx3.c    **** 	}
 730:../sdrx3.c    **** 
 731:../sdrx3.c    **** 	/* Connect the USB Pins with super speed operation enabled. */
 732:../sdrx3.c    **** 	apiRetStatus = CyU3PConnectState(CyTrue, CyTrue);
 1938              		.loc 1 732 0
 1939 0fac 0100A0E3 		mov	r0, #1
 1940 0fb0 0110A0E3 		mov	r1, #1
 1941 0fb4 FEFFFFEB 		bl	CyU3PConnectState
 1942 0fb8 08000BE5 		str	r0, [fp, #-8]
 733:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1943              		.loc 1 733 0
 1944 0fbc 08301BE5 		ldr	r3, [fp, #-8]
 1945 0fc0 000053E3 		cmp	r3, #0
 1946 0fc4 0500000A 		beq	.L87
 734:../sdrx3.c    **** 	{
 735:../sdrx3.c    **** 		CyU3PDebugPrint (4, "USB Connect failed, Error code = %d\n", apiRetStatus);
 1947              		.loc 1 735 0
 1948 0fc8 0400A0E3 		mov	r0, #4
 1949 0fcc 70109FE5 		ldr	r1, .L102+92
 1950 0fd0 08201BE5 		ldr	r2, [fp, #-8]
 1951 0fd4 FEFFFFEB 		bl	CyU3PDebugPrint
 736:../sdrx3.c    **** 		SDR_ErrorHandler(apiRetStatus);
 1952              		.loc 1 736 0
 1953 0fd8 08001BE5 		ldr	r0, [fp, #-8]
 1954 0fdc FEFFFFEB 		bl	SDR_ErrorHandler
 1955              	.L87:
 737:../sdrx3.c    **** 	}
 738:../sdrx3.c    **** 
 739:../sdrx3.c    **** 
 740:../sdrx3.c    **** }
 1956              		.loc 1 740 0
 1957 0fe0 04D04BE2 		sub	sp, fp, #4
 1958              		@ sp needed
 1959 0fe4 0088BDE8 		ldmfd	sp!, {fp, pc}
 1960              	.L103:
 1961              		.align	2
 1962              	.L102:
 1963 0fe8 F0010000 		.word	.LC10
 1964 0fec 00000000 		.word	CyFxGpifConfig
 1965 0ff0 20020000 		.word	.LC11
 1966 0ff4 00000000 		.word	SDR_ApplnGPIFEventCB
 1967 0ff8 48020000 		.word	.LC12
 1968 0ffc 00000000 		.word	SDR_ApplnUSBSetupCB
 1969 1000 00000000 		.word	SDR_ApplnUSBEventCB
 1970 1004 00000000 		.word	CyFxUSB30DeviceDscr
 1971 1008 78020000 		.word	.LC13
 1972 100c 00000000 		.word	CyFxUSB20DeviceDscr
 1973 1010 00000000 		.word	CyFxUSBBOSDscr
 1974 1014 AC020000 		.word	.LC14
 1975 1018 00000000 		.word	CyFxUSBDeviceQualDscr
 1976 101c E8020000 		.word	.LC15
 1977 1020 00000000 		.word	CyFxUSBSSConfigDscr
 1978 1024 00000000 		.word	CyFxUSBHSConfigDscr
 1979 1028 28030000 		.word	.LC16
 1980 102c 00000000 		.word	CyFxUSBFSConfigDscr
 1981 1030 60030000 		.word	.LC17
 1982 1034 00000000 		.word	CyFxUSBStringLangIDDscr
 1983 1038 9C030000 		.word	.LC18
 1984 103c 00000000 		.word	CyFxUSBManufactureDscr
 1985 1040 00000000 		.word	CyFxUSBProductDscr
 1986 1044 D0030000 		.word	.LC19
 1987              		.cfi_endproc
 1988              	.LFE12:
 1990              		.section	.rodata
 1991 03f5 000000   		.align	2
 1992              	.LC20:
 1993 03f8 0A0D2045 		.ascii	"\012\015 Error CyFxI2cInit() = 0x%X\012\000"
 1993      72726F72 
 1993      20437946 
 1993      78493263 
 1993      496E6974 
 1994 0417 00       		.align	2
 1995              	.LC21:
 1996 0418 0A0D2049 		.ascii	"\012\015 Init IOs\000"
 1996      6E697420 
 1996      494F7300 
 1997              		.text
 1998              		.align	2
 1999              		.global	SDR_AppThread_Entry
 2001              	SDR_AppThread_Entry:
 2002              	.LFB13:
 741:../sdrx3.c    **** 
 742:../sdrx3.c    **** /* Entry function for the SDR_AppThread. */
 743:../sdrx3.c    **** void
 744:../sdrx3.c    **** SDR_AppThread_Entry (
 745:../sdrx3.c    **** 		uint32_t input)
 746:../sdrx3.c    **** {
 2003              		.loc 1 746 0
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 16
 2006              		@ frame_needed = 1, uses_anonymous_args = 0
 2007 1048 00482DE9 		stmfd	sp!, {fp, lr}
 2008              	.LCFI26:
 2009              		.cfi_def_cfa_offset 8
 2010              		.cfi_offset 11, -8
 2011              		.cfi_offset 14, -4
 2012 104c 04B08DE2 		add	fp, sp, #4
 2013              	.LCFI27:
 2014              		.cfi_def_cfa 11, 4
 2015 1050 10D04DE2 		sub	sp, sp, #16
 2016 1054 10000BE5 		str	r0, [fp, #-16]
 747:../sdrx3.c    **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 2017              		.loc 1 747 0
 2018 1058 0030A0E3 		mov	r3, #0
 2019 105c 08300BE5 		str	r3, [fp, #-8]
 748:../sdrx3.c    **** 	/* Initialize the debug module */
 749:../sdrx3.c    **** 	SDR_ApplnDebugInit();
 2020              		.loc 1 749 0
 2021 1060 FEFFFFEB 		bl	SDR_ApplnDebugInit
 750:../sdrx3.c    **** 
 751:../sdrx3.c    **** 	/* Initialize GPIO IO */
 752:../sdrx3.c    **** 	SDR_GpioInit();
 2022              		.loc 1 752 0
 2023 1064 FEFFFFEB 		bl	SDR_GpioInit
 753:../sdrx3.c    **** 
 754:../sdrx3.c    ****     apiRetStatus = CyFxI2cInit ();
 2024              		.loc 1 754 0
 2025 1068 FEFFFFEB 		bl	CyFxI2cInit
 2026 106c 08000BE5 		str	r0, [fp, #-8]
 755:../sdrx3.c    **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 2027              		.loc 1 755 0
 2028 1070 08301BE5 		ldr	r3, [fp, #-8]
 2029 1074 000053E3 		cmp	r3, #0
 2030 1078 0300000A 		beq	.L105
 756:../sdrx3.c    **** 		 {
 757:../sdrx3.c    **** 		   // Error handling
 758:../sdrx3.c    **** 		   CyU3PDebugPrint (4, "\n\r Error CyFxI2cInit() = 0x%X\n",apiRetStatus);
 2031              		.loc 1 758 0
 2032 107c 0400A0E3 		mov	r0, #4
 2033 1080 54109FE5 		ldr	r1, .L108
 2034 1084 08201BE5 		ldr	r2, [fp, #-8]
 2035 1088 FEFFFFEB 		bl	CyU3PDebugPrint
 2036              	.L105:
 759:../sdrx3.c    **** 		 }
 760:../sdrx3.c    **** 
 761:../sdrx3.c    **** 	CyU3PDebugPrint (4, "\n\r Init IOs");
 2037              		.loc 1 761 0
 2038 108c 0400A0E3 		mov	r0, #4
 2039 1090 48109FE5 		ldr	r1, .L108+4
 2040 1094 FEFFFFEB 		bl	CyU3PDebugPrint
 762:../sdrx3.c    **** 
 763:../sdrx3.c    **** 	/* Initialize the application */
 764:../sdrx3.c    **** 	SDR_ApplnInit();
 2041              		.loc 1 764 0
 2042 1098 FEFFFFEB 		bl	SDR_ApplnInit
 2043              	.L107:
 765:../sdrx3.c    **** 
 766:../sdrx3.c    **** //	SDR_ErrorHandler(0xca);
 767:../sdrx3.c    **** 
 768:../sdrx3.c    **** 	for (;;)
 769:../sdrx3.c    **** 	{
 770:../sdrx3.c    **** 		CyU3PThreadSleep (2000);
 2044              		.loc 1 770 0
 2045 109c 7D0EA0E3 		mov	r0, #2000
 2046 10a0 FEFFFFEB 		bl	_tx_thread_sleep
 771:../sdrx3.c    **** 
 772:../sdrx3.c    **** 		if (glIsApplnActive)
 2047              		.loc 1 772 0
 2048 10a4 38309FE5 		ldr	r3, .L108+8
 2049 10a8 003093E5 		ldr	r3, [r3]
 2050 10ac 000053E3 		cmp	r3, #0
 2051 10b0 0800000A 		beq	.L106
 773:../sdrx3.c    **** 		{
 774:../sdrx3.c    **** 			if(!glStartSDRGpif)
 2052              		.loc 1 774 0
 2053 10b4 2C309FE5 		ldr	r3, .L108+12
 2054 10b8 003093E5 		ldr	r3, [r3]
 2055 10bc 000053E3 		cmp	r3, #0
 2056 10c0 0400001A 		bne	.L106
 775:../sdrx3.c    **** 			{
 776:../sdrx3.c    **** 				glStartSDRGpif = CyTrue;
 2057              		.loc 1 776 0
 2058 10c4 1C309FE5 		ldr	r3, .L108+12
 2059 10c8 0120A0E3 		mov	r2, #1
 2060 10cc 002083E5 		str	r2, [r3]
 777:../sdrx3.c    **** 				SDR_StartGpif();
 2061              		.loc 1 777 0
 2062 10d0 FEFFFFEB 		bl	SDR_StartGpif
 778:../sdrx3.c    **** 			}
 779:../sdrx3.c    **** 		}
 780:../sdrx3.c    ****         /* Allow other ready threads to run. */
 781:../sdrx3.c    ****    //     CyU3PThreadRelinquish ();
 782:../sdrx3.c    **** 	}
 2063              		.loc 1 782 0
 2064 10d4 F0FFFFEA 		b	.L107
 2065              	.L106:
 2066 10d8 EFFFFFEA 		b	.L107
 2067              	.L109:
 2068              		.align	2
 2069              	.L108:
 2070 10dc F8030000 		.word	.LC20
 2071 10e0 18040000 		.word	.LC21
 2072 10e4 00000000 		.word	glIsApplnActive
 2073 10e8 00000000 		.word	glStartSDRGpif
 2074              		.cfi_endproc
 2075              	.LFE13:
 2077              		.section	.rodata
 2078              		.align	2
 2079              	.LC22:
 2080 0424 32313A42 		.ascii	"21:Bulk_src_sink\000"
 2080      756C6B5F 
 2080      7372635F 
 2080      73696E6B 
 2080      00
 2081 0435 00000000 		.text
 2081      00000000 
 2081      000000
 2082              		.align	2
 2083              		.global	CyFxApplicationDefine
 2085              	CyFxApplicationDefine:
 2086              	.LFB14:
 783:../sdrx3.c    **** }
 784:../sdrx3.c    **** 
 785:../sdrx3.c    **** /* Application define function which creates the threads. */
 786:../sdrx3.c    **** void
 787:../sdrx3.c    **** CyFxApplicationDefine (
 788:../sdrx3.c    **** 		void)
 789:../sdrx3.c    **** {
 2087              		.loc 1 789 0
 2088              		.cfi_startproc
 2089              		@ args = 0, pretend = 0, frame = 8
 2090              		@ frame_needed = 1, uses_anonymous_args = 0
 2091 10ec 00482DE9 		stmfd	sp!, {fp, lr}
 2092              	.LCFI28:
 2093              		.cfi_def_cfa_offset 8
 2094              		.cfi_offset 11, -8
 2095              		.cfi_offset 14, -4
 2096 10f0 04B08DE2 		add	fp, sp, #4
 2097              	.LCFI29:
 2098              		.cfi_def_cfa 11, 4
 2099 10f4 28D04DE2 		sub	sp, sp, #40
 790:../sdrx3.c    **** 	void *ptr = NULL;
 2100              		.loc 1 790 0
 2101 10f8 0030A0E3 		mov	r3, #0
 2102 10fc 08300BE5 		str	r3, [fp, #-8]
 791:../sdrx3.c    **** 	uint32_t retThrdCreate = CY_U3P_SUCCESS;
 2103              		.loc 1 791 0
 2104 1100 0030A0E3 		mov	r3, #0
 2105 1104 0C300BE5 		str	r3, [fp, #-12]
 792:../sdrx3.c    **** 
 793:../sdrx3.c    **** 	/* Allocate the memory for the threads */
 794:../sdrx3.c    **** 	ptr = CyU3PMemAlloc (CY_FX_BULKSRCSINK_THREAD_STACK);
 2106              		.loc 1 794 0
 2107 1108 010AA0E3 		mov	r0, #4096
 2108 110c FEFFFFEB 		bl	CyU3PMemAlloc
 2109 1110 08000BE5 		str	r0, [fp, #-8]
 795:../sdrx3.c    **** 
 796:../sdrx3.c    **** 	/* Create the thread for the application */
 797:../sdrx3.c    **** 	retThrdCreate = CyU3PThreadCreate (&SDR_AppThread,      /* App thread structure */
 2110              		.loc 1 797 0
 2111 1114 08301BE5 		ldr	r3, [fp, #-8]
 2112 1118 00308DE5 		str	r3, [sp]
 2113 111c 013AA0E3 		mov	r3, #4096
 2114 1120 04308DE5 		str	r3, [sp, #4]
 2115 1124 0830A0E3 		mov	r3, #8
 2116 1128 08308DE5 		str	r3, [sp, #8]
 2117 112c 0830A0E3 		mov	r3, #8
 2118 1130 0C308DE5 		str	r3, [sp, #12]
 2119 1134 0030A0E3 		mov	r3, #0
 2120 1138 10308DE5 		str	r3, [sp, #16]
 2121 113c 0130A0E3 		mov	r3, #1
 2122 1140 14308DE5 		str	r3, [sp, #20]
 2123 1144 A830A0E3 		mov	r3, #168
 2124 1148 18308DE5 		str	r3, [sp, #24]
 2125 114c 28009FE5 		ldr	r0, .L113
 2126 1150 28109FE5 		ldr	r1, .L113+4
 2127 1154 28209FE5 		ldr	r2, .L113+8
 2128 1158 0030A0E3 		mov	r3, #0
 2129 115c FEFFFFEB 		bl	_txe_thread_create
 2130 1160 0C000BE5 		str	r0, [fp, #-12]
 798:../sdrx3.c    **** 			"21:Bulk_src_sink",                      /* Thread ID and thread name */
 799:../sdrx3.c    **** 			SDR_AppThread_Entry,              /* App thread entry function */
 800:../sdrx3.c    **** 			0,                                       /* No input parameter to thread */
 801:../sdrx3.c    **** 			ptr,                                     /* Pointer to the allocated thread stack */
 802:../sdrx3.c    **** 			CY_FX_BULKSRCSINK_THREAD_STACK,          /* App thread stack size */
 803:../sdrx3.c    **** 			CY_FX_BULKSRCSINK_THREAD_PRIORITY,       /* App thread priority */
 804:../sdrx3.c    **** 			CY_FX_BULKSRCSINK_THREAD_PRIORITY,       /* App thread priority */
 805:../sdrx3.c    **** 			CYU3P_NO_TIME_SLICE,                     /* No time slice for the application thread */
 806:../sdrx3.c    **** 			CYU3P_AUTO_START                         /* Start the thread immediately */
 807:../sdrx3.c    **** 	);
 808:../sdrx3.c    **** 
 809:../sdrx3.c    **** 	/* Check the return code */
 810:../sdrx3.c    **** 	if (retThrdCreate != 0)
 2131              		.loc 1 810 0
 2132 1164 0C301BE5 		ldr	r3, [fp, #-12]
 2133 1168 000053E3 		cmp	r3, #0
 2134 116c 0000000A 		beq	.L110
 2135              	.L112:
 811:../sdrx3.c    **** 	{
 812:../sdrx3.c    **** 		/* Thread Creation failed with the error code retThrdCreate */
 813:../sdrx3.c    **** 
 814:../sdrx3.c    **** 		/* Add custom recovery or debug actions here */
 815:../sdrx3.c    **** 
 816:../sdrx3.c    **** 		/* Application cannot continue */
 817:../sdrx3.c    **** 		/* Loop indefinitely */
 818:../sdrx3.c    **** 		while(1);
 2136              		.loc 1 818 0 discriminator 1
 2137 1170 FEFFFFEA 		b	.L112
 2138              	.L110:
 819:../sdrx3.c    **** 	}
 820:../sdrx3.c    **** }
 2139              		.loc 1 820 0
 2140 1174 04D04BE2 		sub	sp, fp, #4
 2141              		@ sp needed
 2142 1178 0088BDE8 		ldmfd	sp!, {fp, pc}
 2143              	.L114:
 2144              		.align	2
 2145              	.L113:
 2146 117c 00000000 		.word	SDR_AppThread
 2147 1180 24040000 		.word	.LC22
 2148 1184 00000000 		.word	SDR_AppThread_Entry
 2149              		.cfi_endproc
 2150              	.LFE14:
 2152              		.align	2
 2153              		.global	main
 2155              	main:
 2156              	.LFB15:
 821:../sdrx3.c    **** 
 822:../sdrx3.c    **** /*
 823:../sdrx3.c    ****  * Main function
 824:../sdrx3.c    ****  */
 825:../sdrx3.c    **** int
 826:../sdrx3.c    **** main (void)
 827:../sdrx3.c    **** {
 2157              		.loc 1 827 0
 2158              		.cfi_startproc
 2159              		@ args = 0, pretend = 0, frame = 48
 2160              		@ frame_needed = 1, uses_anonymous_args = 0
 2161 1188 00482DE9 		stmfd	sp!, {fp, lr}
 2162              	.LCFI30:
 2163              		.cfi_def_cfa_offset 8
 2164              		.cfi_offset 11, -8
 2165              		.cfi_offset 14, -4
 2166 118c 04B08DE2 		add	fp, sp, #4
 2167              	.LCFI31:
 2168              		.cfi_def_cfa 11, 4
 2169 1190 30D04DE2 		sub	sp, sp, #48
 828:../sdrx3.c    **** 	CyU3PIoMatrixConfig_t io_cfg;
 829:../sdrx3.c    **** 	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 2170              		.loc 1 829 0
 2171 1194 0030A0E3 		mov	r3, #0
 2172 1198 08300BE5 		str	r3, [fp, #-8]
 830:../sdrx3.c    **** 
 831:../sdrx3.c    **** 	/* Initialize the device */
 832:../sdrx3.c    **** 	status = CyU3PDeviceInit (NULL);
 2173              		.loc 1 832 0
 2174 119c 0000A0E3 		mov	r0, #0
 2175 11a0 FEFFFFEB 		bl	CyU3PDeviceInit
 2176 11a4 08000BE5 		str	r0, [fp, #-8]
 833:../sdrx3.c    **** 	if (status != CY_U3P_SUCCESS)
 2177              		.loc 1 833 0
 2178 11a8 08301BE5 		ldr	r3, [fp, #-8]
 2179 11ac 000053E3 		cmp	r3, #0
 2180 11b0 0000000A 		beq	.L116
 834:../sdrx3.c    **** 	{
 835:../sdrx3.c    **** 		goto handle_fatal_error;
 2181              		.loc 1 835 0
 2182 11b4 270000EA 		b	.L117
 2183              	.L116:
 836:../sdrx3.c    **** 	}
 837:../sdrx3.c    **** 
 838:../sdrx3.c    **** 	/* Initialize the caches. Enable instruction cache and keep data cache disabled.
 839:../sdrx3.c    **** 	 * The data cache is useful only when there is a large amount of CPU based memory
 840:../sdrx3.c    **** 	 * accesses. When used in simple cases, it can decrease performance due to large
 841:../sdrx3.c    **** 	 * number of cache flushes and cleans and also it adds to the complexity of the
 842:../sdrx3.c    **** 	 * code. */
 843:../sdrx3.c    **** 	status = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 2184              		.loc 1 843 0
 2185 11b8 0100A0E3 		mov	r0, #1
 2186 11bc 0010A0E3 		mov	r1, #0
 2187 11c0 0020A0E3 		mov	r2, #0
 2188 11c4 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 2189 11c8 08000BE5 		str	r0, [fp, #-8]
 844:../sdrx3.c    **** 	if (status != CY_U3P_SUCCESS)
 2190              		.loc 1 844 0
 2191 11cc 08301BE5 		ldr	r3, [fp, #-8]
 2192 11d0 000053E3 		cmp	r3, #0
 2193 11d4 0000000A 		beq	.L118
 845:../sdrx3.c    **** 	{
 846:../sdrx3.c    **** 		goto handle_fatal_error;
 2194              		.loc 1 846 0
 2195 11d8 1E0000EA 		b	.L117
 2196              	.L118:
 847:../sdrx3.c    **** 	}
 848:../sdrx3.c    **** 
 849:../sdrx3.c    **** 	/* Configure the IO matrix for the device. On the FX3 DVK board, the COM port
 850:../sdrx3.c    **** 	 * is connected to the IO(53:56). This means that either DQ32 mode should be
 851:../sdrx3.c    **** 	 * selected or lppMode should be set to UART_ONLY. Here we are choosing
 852:../sdrx3.c    **** 	 * UART_ONLY configuration. */
 853:../sdrx3.c    **** 	io_cfg.isDQ32Bit = CyTrue;
 2197              		.loc 1 853 0
 2198 11dc 0130A0E3 		mov	r3, #1
 2199 11e0 30300BE5 		str	r3, [fp, #-48]
 854:../sdrx3.c    **** 	io_cfg.useUart   = CyTrue;
 2200              		.loc 1 854 0
 2201 11e4 0130A0E3 		mov	r3, #1
 2202 11e8 2C300BE5 		str	r3, [fp, #-44]
 855:../sdrx3.c    **** #ifdef I2C_ACTIVE
 856:../sdrx3.c    **** 	io_cfg.useI2C    = CyTrue;
 2203              		.loc 1 856 0
 2204 11ec 0130A0E3 		mov	r3, #1
 2205 11f0 28300BE5 		str	r3, [fp, #-40]
 857:../sdrx3.c    **** #else
 858:../sdrx3.c    **** 	io_cfg.useI2C    = CyFalse;
 859:../sdrx3.c    **** #endif
 860:../sdrx3.c    **** 	io_cfg.useI2S    = CyFalse;
 2206              		.loc 1 860 0
 2207 11f4 0030A0E3 		mov	r3, #0
 2208 11f8 24300BE5 		str	r3, [fp, #-36]
 861:../sdrx3.c    **** 	io_cfg.useSpi    = CyFalse;
 2209              		.loc 1 861 0
 2210 11fc 0030A0E3 		mov	r3, #0
 2211 1200 20300BE5 		str	r3, [fp, #-32]
 862:../sdrx3.c    **** 	io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 2212              		.loc 1 862 0
 2213 1204 0030A0E3 		mov	r3, #0
 2214 1208 1A304BE5 		strb	r3, [fp, #-26]
 863:../sdrx3.c    **** 	/* No GPIOs are enabled. */
 864:../sdrx3.c    **** 	io_cfg.gpioSimpleEn[0]  = 0;
 2215              		.loc 1 864 0
 2216 120c 0030A0E3 		mov	r3, #0
 2217 1210 18300BE5 		str	r3, [fp, #-24]
 865:../sdrx3.c    **** 	io_cfg.gpioSimpleEn[1]  = 0;
 2218              		.loc 1 865 0
 2219 1214 0030A0E3 		mov	r3, #0
 2220 1218 14300BE5 		str	r3, [fp, #-20]
 866:../sdrx3.c    ****     /* GPIOs 50 is used as complex GPIO. */
 867:../sdrx3.c    ****     io_cfg.gpioComplexEn[0] = 0x01000000;  // GPIO24 PWM
 2221              		.loc 1 867 0
 2222 121c 0134A0E3 		mov	r3, #16777216
 2223 1220 10300BE5 		str	r3, [fp, #-16]
 868:../sdrx3.c    ****     io_cfg.gpioComplexEn[1] = 0x00000000;
 2224              		.loc 1 868 0
 2225 1224 0030A0E3 		mov	r3, #0
 2226 1228 0C300BE5 		str	r3, [fp, #-12]
 869:../sdrx3.c    **** 
 870:../sdrx3.c    **** 	status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 2227              		.loc 1 870 0
 2228 122c 30304BE2 		sub	r3, fp, #48
 2229 1230 0300A0E1 		mov	r0, r3
 2230 1234 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 2231 1238 08000BE5 		str	r0, [fp, #-8]
 871:../sdrx3.c    **** 	if (status != CY_U3P_SUCCESS)
 2232              		.loc 1 871 0
 2233 123c 08301BE5 		ldr	r3, [fp, #-8]
 2234 1240 000053E3 		cmp	r3, #0
 2235 1244 0000000A 		beq	.L119
 872:../sdrx3.c    **** 	{
 873:../sdrx3.c    **** 		goto handle_fatal_error;
 2236              		.loc 1 873 0
 2237 1248 020000EA 		b	.L117
 2238              	.L119:
 874:../sdrx3.c    **** 	}
 875:../sdrx3.c    **** 
 876:../sdrx3.c    **** 	/* This is a non returnable call for initializing the RTOS kernel */
 877:../sdrx3.c    **** 	CyU3PKernelEntry ();
 2239              		.loc 1 877 0
 2240 124c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 878:../sdrx3.c    **** 
 879:../sdrx3.c    **** 	/* Dummy return to make the compiler happy */
 880:../sdrx3.c    **** 	return 0;
 2241              		.loc 1 880 0
 2242 1250 0030A0E3 		mov	r3, #0
 2243 1254 000000EA 		b	.L121
 2244              	.L117:
 881:../sdrx3.c    **** 
 882:../sdrx3.c    **** 	handle_fatal_error:
 883:../sdrx3.c    **** 
 884:../sdrx3.c    **** 	/* Cannot recover from this error. */
 885:../sdrx3.c    **** 	while (1);
 2245              		.loc 1 885 0 discriminator 1
 2246 1258 FEFFFFEA 		b	.L117
 2247              	.L121:
 886:../sdrx3.c    **** }
 2248              		.loc 1 886 0
 2249 125c 0300A0E1 		mov	r0, r3
 2250 1260 04D04BE2 		sub	sp, fp, #4
 2251              		@ sp needed
 2252 1264 0088BDE8 		ldmfd	sp!, {fp, pc}
 2253              		.cfi_endproc
 2254              	.LFE15:
 2256              	.Letext0:
 2257              		.file 2 "d:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 2258              		.file 3 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 2259              		.file 4 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 2260              		.file 5 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 2261              		.file 6 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 2262              		.file 7 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 2263              		.file 8 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 2264              		.file 9 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 2265              		.file 10 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2266              		.file 11 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2267              		.file 12 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2268              		.file 13 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2269              		.file 14 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2270              		.file 15 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2271              		.file 16 "D:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 2272              		.file 17 "../sdrx3.h"
 2273              		.file 18 "../cyfxgpif2config.h"
DEFINED SYMBOLS
                            *ABS*:00000000 sdrx3.c
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:21     .data:00000000 CyFxGpifTransition
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:18     .data:00000000 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:30     .data:00000008 CyFxGpifWavedata
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:71     .data:00000098 CyFxGpifWavedataPosition
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:85     .data:000000a4 CyFxGpifRegValue
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:167    .rodata:00000000 CyFxGpifConfig
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:164    .rodata:00000000 $d
                            *COM*:00000020 glEp0Buffer
                            *COM*:00000002 glRecvdLen
                            *COM*:000000a8 SDR_AppThread
                            *COM*:000000e8 glChHandleBulkSrc
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:187    .bss:00000000 glIsApplnActive
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:184    .bss:00000000 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:193    .bss:00000004 glStartSDRGpif
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:199    .bss:00000008 glDMARxCount
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:205    .bss:0000000c glDMATxCount
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:212    .rodata:00000020 glFirmwareID
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:223    .text:00000000 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:226    .text:00000000 SDR_ErrorHandler
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:329    .text:000000ec SDR_GpioIntrCb
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:372    .text:00000138 ConfGPIOsimpleout
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:449    .text:000001e0 ConfGPIOPWM
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:531    .text:000002a0 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:540    .text:000002a4 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:543    .text:000002a4 SDR_GpioInit
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:639    .text:00000388 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:645    .text:00000394 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:648    .text:00000394 SDR_ApplnDebugInit
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:753    .text:0000048c $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:771    .text:00000490 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:774    .text:00000490 SDR_ApplnStart
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:986    .text:000006b0 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:997    .text:000006d0 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1000   .text:000006d0 SDR_ApplnStop
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1063   .text:0000075c $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1083   .text:00000768 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1086   .text:00000768 SDR_ApplnUSBSetupCB
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1146   .text:000007f8 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1162   .text:00000830 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1430   .text:00000b68 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1445   .text:00000b84 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1448   .text:00000b84 SDR_ApplnGPIFEventCB
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1488   .text:00000bc8 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1492   .text:00000bcc $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1495   .text:00000bcc SDR_ApplnUSBEventCB
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1558   .text:00000c48 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1568   .text:00000c4c $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1571   .text:00000c4c SDR_StartGpif
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1611   .text:00000c94 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1653   .text:00000c98 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1656   .text:00000c98 SDR_ApplnInit
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1963   .text:00000fe8 $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:1998   .text:00001048 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2001   .text:00001048 SDR_AppThread_Entry
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2070   .text:000010dc $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2082   .text:000010ec $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2085   .text:000010ec CyFxApplicationDefine
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2146   .text:0000117c $d
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2152   .text:00001188 $a
C:\Users\jason\AppData\Local\Temp\cc1QtI7L.s:2155   .text:00001188 main
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PGpioSetValue
_tx_thread_sleep
CyU3PGpioGetValue
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PGpioSetComplexConfig
CyU3PGpioInit
CyU3PDebugPrint
CyU3PUartInit
CyU3PMemSet
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PUsbGetSpeed
CyU3PSetEpConfig
CyU3PDmaMultiChannelCreate
CyU3PDmaMultiChannelSetXfer
CyU3PUsbFlushEp
CyU3PDmaMultiChannelDestroy
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyFxUsbI2cTransfer
CyU3PGpifSMStart
CyU3PPibInit
CyU3PGpifLoad
CyU3PGpifRegisterCallback
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PConnectState
CyFxUSB30DeviceDscr
CyFxUSB20DeviceDscr
CyFxUSBBOSDscr
CyFxUSBDeviceQualDscr
CyFxUSBSSConfigDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyFxI2cInit
CyU3PMemAlloc
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
